<!DOCTYPE html><!--Author: Pranav Rajpurkar 2016--><html><head><meta charset="utf-8"><title>SQuAD - the Stanford Question Answering Dataset</title><meta name="description" content="SQuAD is the Stanford Question Answering Dataset"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"><meta property="og:image" content="/logo.png"><link rel="image_src" type="image/png" href="/SQuAD-explorer/logo.png"><link rel="shortcut icon" href="/SQuAD-explorer/favicon.ico" type="image/x-icon"><link rel="icon" href="/SQuAD-explorer/favicon.ico" type="image/x-icon"><link rel="stylesheet" href="/SQuAD-explorer/bower_components/bootstrap/dist/css/bootstrap.min.css"><link rel="stylesheet" href="/SQuAD-explorer/stylesheets/layout.css"><link rel="stylesheet" href="/SQuAD-explorer/stylesheets/article.css"><script src="/SQuAD-explorer/javascripts/analytics.js"></script></head><body><div class="navbar navbar-default navbar-fixed-top" id="topNavbar" role="navigation"><div class="container clearfix" id="navContainer"><div class="rightNav"><div class="collapseDiv"><button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar"><span class="glyphicon glyphicon-menu-hamburger"></span></button></div><div class="collapse navbar-collapse" id="navbar"><ul class="nav navbar-nav navbar-right"><li><a href="/SQuAD-explorer/">Home</a></li><li><a href="/SQuAD-explorer/explore/v2.0/dev/">Explore 2.0</a></li><li><a href="/SQuAD-explorer/explore/1.1/dev/">Explore 1.1</a></li></ul></div></div><div class="leftNav"><div class="brandDiv"><a class="navbar-brand" href="/SQuAD-explorer/">SQuAD</a></div></div></div></div><div class="cover" id="topCover"><div class="container"><div class="row"><div class="col-md-12"><h1 id="appTitle">SQuAD<b>2.0</b></h1><h2 id="appSubtitle">The Stanford Question Answering Dataset</h2></div></div></div></div><div class="cover"><div class="container"><div class="row"><div class="col-md-12"><div class="infoCard"><div class="infoSubheadline model-title-holder"><h1>Predictions</h1><h2>Scores</h2></div><div class="infoBody"><h1 id="title">Computational_complexity_theory</h1><h2 id="subtitle">The Stanford Question Answering Dataset</h2><div>        <div class="para-wrap"><div class="row"><div class="col-md-6"><pre>Computational complexity theory is a branch of the theory of computation in theoretical computer science that focuses on classifying computational problems according to their inherent difficulty, and relating those classes to each other. A computational problem is understood to be a task that is in principle amenable to being solved by a computer, which is equivalent to stating that the problem may be solved by mechanical application of mathematical steps, such as an algorithm.</pre></div><div class="col-md-6"><div class="qas-wrap"><div class="qa-wrap" data-id="56e16182e3433e1400422e28"><p> <strong class="question">What branch of theoretical computer science deals with broadly classifying computational problems by difficulty and class of relationship?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">Computational complexity theory</span><span class="answer">Computational complexity theory</span><span class="answer">Computational complexity theory</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="56e16182e3433e1400422e29"><p> <strong class="question">By what main attribute are computational problems classified utilizing computational complexity theory? </strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">inherent difficulty</span><span class="answer">their inherent difficulty</span><span class="answer">inherent difficulty</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="56e16182e3433e1400422e2a"><p> <strong class="question">What is the term for a task that generally lends itself to being solved by a computer?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">computational problems</span><span class="answer">A computational problem</span><span class="answer">computational problem</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad5316b5b96ef001a10ab72"><p> <strong class="question">What is computational complexity principle?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad5316b5b96ef001a10ab73"><p> <strong class="question">What branch of theoretical computer class deals with broadly classifying computational problems by difficulty and class of relationship?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad5316b5b96ef001a10ab74"><p> <strong class="question">What is understood to be a task that is in principle not amendable to being solved by a computer?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad5316b5b96ef001a10ab75"><p> <strong class="question"> What cannot be solved by mechanical application of mathematical steps?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad5316b5b96ef001a10ab76"><p> <strong class="question">What is a manual application of mathematical steps?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div></div></div></div></div><div class="para-wrap"><div class="row"><div class="col-md-6"><pre>A problem is regarded as inherently difficult if its solution requires significant resources, whatever the algorithm used. The theory formalizes this intuition, by introducing mathematical models of computation to study these problems and quantifying the amount of resources needed to solve them, such as time and storage. Other complexity measures are also used, such as the amount of communication (used in communication complexity), the number of gates in a circuit (used in circuit complexity) and the number of processors (used in parallel computing). One of the roles of computational complexity theory is to determine the practical limits on what computers can and cannot do.</pre></div><div class="col-md-6"><div class="qas-wrap"><div class="qa-wrap" data-id="56e16839cd28a01900c67887"><p> <strong class="question">What measure of a computational problem broadly defines the inherent difficulty of the solution?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">if its solution requires significant resources</span><span class="answer">its solution requires significant resources</span><span class="answer">if its solution requires significant resources</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="56e16839cd28a01900c67888"><p> <strong class="question">What method is used to intuitively assess or quantify the amount of resources required to solve a computational problem?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">mathematical models of computation</span><span class="answer">mathematical models of computation</span><span class="answer">mathematical models of computation</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="56e16839cd28a01900c67889"><p> <strong class="question">What are two basic primary resources used to guage complexity?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">time and storage</span><span class="answer">time and storage</span><span class="answer">time and storage</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="56e16839cd28a01900c6788a"><p> <strong class="question">What unit is measured to determine circuit complexity?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">number of gates in a circuit</span><span class="answer">number of gates in a circuit</span><span class="answer">number of gates</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="56e16839cd28a01900c6788b"><p> <strong class="question">What practical role does defining the complexity of problems play in everyday computing?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">determine the practical limits on what computers can and cannot do</span><span class="answer">what computers can and cannot do</span><span class="answer">determine the practical limits on what computers can and cannot do</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad532575b96ef001a10ab7c"><p> <strong class="question">What measure of computational problem broadly defines the inherent simplicity of the solution?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad532575b96ef001a10ab7d"><p> <strong class="question">What method is not used to intuitively assess or quantify the amount of resources required to solve a computational problem??</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad532575b96ef001a10ab7e"><p> <strong class="question">What are three basic primary resources used to gauge complexity?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad532575b96ef001a10ab7f"><p> <strong class="question">What unit is measured to determine circuit simplicity?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad532575b96ef001a10ab80"><p> <strong class="question">What number is used in perpendicular computing?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div></div></div></div></div><div class="para-wrap"><div class="row"><div class="col-md-6"><pre>Closely related fields in theoretical computer science are analysis of algorithms and computability theory. A key distinction between analysis of algorithms and computational complexity theory is that the former is devoted to analyzing the amount of resources needed by a particular algorithm to solve a problem, whereas the latter asks a more general question about all possible algorithms that could be used to solve the same problem. More precisely, it tries to classify problems that can or cannot be solved with appropriately restricted resources. In turn, imposing restrictions on the available resources is what distinguishes computational complexity from computability theory: the latter theory asks what kind of problems can, in principle, be solved algorithmically.</pre></div><div class="col-md-6"><div class="qas-wrap"><div class="qa-wrap" data-id="56e17644e3433e1400422f40"><p> <strong class="question">What two fields of theoretical computer science closely mirror computational complexity theory?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">analysis of algorithms and computability theory</span><span class="answer">analysis of algorithms and computability theory</span><span class="answer">analysis of algorithms and computability theory</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="56e17644e3433e1400422f41"><p> <strong class="question">What field of computer science analyzes the resource requirements of a specific algorithm isolated unto itself within a given problem?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">analysis of algorithms</span><span class="answer">analysis of algorithms</span><span class="answer">analysis of algorithms</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="56e17644e3433e1400422f42"><p> <strong class="question">What field of computer science analyzes all possible algorithms in aggregate to determine the resource requirements needed to solve to a given problem?  </strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">computational complexity theory</span><span class="answer">computational complexity theory</span><span class="answer">computational complexity theory</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="56e17644e3433e1400422f43"><p> <strong class="question">What field of computer science is primarily concerned with determining the likelihood of whether or not a problem can ultimately be solved using algorithms?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">computability theory</span><span class="answer">computability theory</span><span class="answer">computability theory</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad5344b5b96ef001a10ab86"><p> <strong class="question">What are two fields of theoretical computer science that closely mirror computational simplicity theory?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad5344b5b96ef001a10ab87"><p> <strong class="question">What is not the key distinction between analysis of algorithms and computational complexity theory?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad5344b5b96ef001a10ab88"><p> <strong class="question">What is the process of analyzing the amount of resources needed by a particular algorithm to solve a hypothesis?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad5344b5b96ef001a10ab89"><p> <strong class="question">What is the process that asks a more specific question about all possible algorithms that could not be used to solve the same problem?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad5344b5b96ef001a10ab8a"><p> <strong class="question">What process classifies problems that can and cannot be solved with approximately unlimited resources?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div></div></div></div></div><div class="para-wrap"><div class="row"><div class="col-md-6"><pre>A computational problem can be viewed as an infinite collection of instances together with a solution for every instance. The input string for a computational problem is referred to as a problem instance, and should not be confused with the problem itself. In computational complexity theory, a problem refers to the abstract question to be solved. In contrast, an instance of this problem is a rather concrete utterance, which can serve as the input for a decision problem. For example, consider the problem of primality testing. The instance is a number (e.g. 15) and the solution is &quot;yes&quot; if the number is prime and &quot;no&quot; otherwise (in this case &quot;no&quot;). Stated another way, the instance is a particular input to the problem, and the solution is the output corresponding to the given input.</pre></div><div class="col-md-6"><div class="qas-wrap"><div class="qa-wrap" data-id="56e17a7ccd28a01900c679a1"><p> <strong class="question">What is the name given to the input string of a computational problem?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">problem instance</span><span class="answer">a problem instance</span><span class="answer">problem instance</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="56e17a7ccd28a01900c679a2"><p> <strong class="question">In computational complexity theory, what is the term given to describe the baseline abstract question needing to be solved? </strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">the problem</span><span class="answer">a problem</span><span class="answer">problem</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="56e17a7ccd28a01900c679a3"><p> <strong class="question">Is a problem instance typically characterized as abstract or concrete?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">concrete</span><span class="answer">concrete</span><span class="answer">abstract</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="56e17a7ccd28a01900c679a4"><p> <strong class="question">What is another name for any given measure of input associated with a problem?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">instances</span><span class="answer">the instance</span><span class="answer">instance</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="56e17a7ccd28a01900c679a5"><p> <strong class="question">What is the general term used to describe the output to any given input in a problem instance?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">solution</span><span class="answer">the solution</span><span class="answer">solution</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad5364c5b96ef001a10ab90"><p> <strong class="question">What can be viewed as a limited collection of instances together with a solution for every instance?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad5364c5b96ef001a10ab91"><p> <strong class="question">What is the name given to the input string of a computational solution?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad5364c5b96ef001a10ab92"><p> <strong class="question">What term refers to the concrete question to be solved?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad5364c5b96ef001a10ab93"><p> <strong class="question">What is the output corresponding to the given question?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad5364c5b96ef001a10ab94"><p> <strong class="question">What is a particular measure input associated with the a theory?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div></div></div></div></div><div class="para-wrap"><div class="row"><div class="col-md-6"><pre>To further highlight the difference between a problem and an instance, consider the following instance of the decision version of the traveling salesman problem: Is there a route of at most 2000 kilometres passing through all of Germany's 15 largest cities? The quantitative answer to this particular problem instance is of little use for solving other instances of the problem, such as asking for a round trip through all sites in Milan whose total length is at most 10 km. For this reason, complexity theory addresses computational problems and not particular problem instances.</pre></div><div class="col-md-6"><div class="qas-wrap"><div class="qa-wrap" data-id="56e17e6ee3433e1400422f7f"><p> <strong class="question">By how many kilometers does the traveling salesman problem seek to classify a route between the 15 largest cities in Germany?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">2000</span><span class="answer">2000</span><span class="answer">2000</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="56e17e6ee3433e1400422f80"><p> <strong class="question">What is one example of an instance that the quantitative answer to the traveling salesman problem fails to answer?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">round trip through all sites in Milan</span><span class="answer">asking for a round trip through all sites in Milan whose total length is at most 10 km</span><span class="answer">a round trip through all sites in Milan whose total length is at most 10 km</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="56e17e6ee3433e1400422f81"><p> <strong class="question">What does computational complexity theory most specifically seek to answer? </strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">computational problems</span><span class="answer">computational problems</span><span class="answer">computational problems</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad537a15b96ef001a10ab9a"><p> <strong class="question">How many miles does the traveling salesman problem seek to classify a route between the 15 smallest cities in Germany?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad537a15b96ef001a10ab9b"><p> <strong class="question">What is the qualitative answer to this particular problem instance?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad537a15b96ef001a10ab9c"><p> <strong class="question">What is one example of an instance that the qualitative answer to the traveling salesman fails to answer?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad537a15b96ef001a10ab9d"><p> <strong class="question">What does computational simplicity theory most specifically seek to answer?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div></div></div></div></div><div class="para-wrap"><div class="row"><div class="col-md-6"><pre>When considering computational problems, a problem instance is a string over an alphabet. Usually, the alphabet is taken to be the binary alphabet (i.e., the set {0,1}), and thus the strings are bitstrings. As in a real-world computer, mathematical objects other than bitstrings must be suitably encoded. For example, integers can be represented in binary notation, and graphs can be encoded directly via their adjacency matrices, or by encoding their adjacency lists in binary.</pre></div><div class="col-md-6"><div class="qas-wrap"><div class="qa-wrap" data-id="56e181d9e3433e1400422fa0"><p> <strong class="question">In a computational problem, what can be described as a string over an alphabet?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">problem instance</span><span class="answer">a problem instance</span><span class="answer">problem instance</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="56e181d9e3433e1400422fa1"><p> <strong class="question">What is the name of the alphabet is most commonly used in a problem instance?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">binary alphabet</span><span class="answer">binary</span><span class="answer">binary</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="56e181d9e3433e1400422fa2"><p> <strong class="question">What is another term for the string of a problem instance?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">bitstrings</span><span class="answer">bitstrings</span><span class="answer">bitstrings</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="56e181d9e3433e1400422fa3"><p> <strong class="question">In the encoding of mathematical objects, what is the way in which integers are commonly expressed?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">binary notation</span><span class="answer">binary notation</span><span class="answer">binary notation</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="56e181d9e3433e1400422fa4"><p> <strong class="question">What is one way in which graphs can be encoded? </strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">adjacency matrices</span><span class="answer">directly via their adjacency matrices</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad5391e5b96ef001a10aba2"><p> <strong class="question">What is a string over a Greek number when considering a computational problem?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad5391e5b96ef001a10aba3"><p> <strong class="question">What is the name of the alphabet that is rarely used in a problem instance?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad5391e5b96ef001a10aba4"><p> <strong class="question">What is another term for the the string of a problem question?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad5391e5b96ef001a10aba5"><p> <strong class="question">What is represented by non-binary notation in the encoding of mathematical objects?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad5391e5b96ef001a10aba6"><p> <strong class="question">How can graphs be encoded indirectly?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div></div></div></div></div><div class="para-wrap"><div class="row"><div class="col-md-6"><pre>Decision problems are one of the central objects of study in computational complexity theory. A decision problem is a special type of computational problem whose answer is either yes or no, or alternately either 1 or 0. A decision problem can be viewed as a formal language, where the members of the language are instances whose output is yes, and the non-members are those instances whose output is no. The objective is to decide, with the aid of an algorithm, whether a given input string is a member of the formal language under consideration. If the algorithm deciding this problem returns the answer yes, the algorithm is said to accept the input string, otherwise it is said to reject the input.</pre></div><div class="col-md-6"><div class="qas-wrap"><div class="qa-wrap" data-id="56e190bce3433e1400422fc8"><p> <strong class="question">What kind of problems are one of the main topics studied in computational complexity theory?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">Decision problems</span><span class="answer">Decision problems</span><span class="answer">Decision</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="56e190bce3433e1400422fc9"><p> <strong class="question">What are the two simple word responses to a decision problem?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">yes or no</span><span class="answer">yes or no</span><span class="answer">yes or no</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="56e190bce3433e1400422fca"><p> <strong class="question">What are the two integer responses to a decision problem?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">1 or 0</span><span class="answer">1 or 0</span><span class="answer">1 or 0</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="56e190bce3433e1400422fcb"><p> <strong class="question">What will the output be for a member of the language of a decision problem?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">yes</span><span class="answer">yes</span><span class="answer">yes</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="56e190bce3433e1400422fcc"><p> <strong class="question">What answer denotes that an algorithm has accepted an input string?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">yes</span><span class="answer">yes</span><span class="answer">yes</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad53b9d5b96ef001a10abc8"><p> <strong class="question">What kind of solutions are one of the central objects of study in computational complexity theory?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad53b9d5b96ef001a10abc9"><p> <strong class="question">What is a typical type of computational problem whose answer is either yer or no?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad53b9d5b96ef001a10abca"><p> <strong class="question">What can be viewed as an informal language where the language instances whose input is yes?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad53b9d5b96ef001a10abcb"><p> <strong class="question">What are the three integer responses to a decision problem?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad53b9d5b96ef001a10abcc"><p> <strong class="question">What answer denotes that a solution has accepted an input string?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div></div></div></div></div><div class="para-wrap"><div class="row"><div class="col-md-6"><pre>An example of a decision problem is the following. The input is an arbitrary graph. The problem consists in deciding whether the given graph is connected, or not. The formal language associated with this decision problem is then the set of all connected graphs—of course, to obtain a precise definition of this language, one has to decide how graphs are encoded as binary strings.</pre></div><div class="col-md-6"><div class="qas-wrap"><div class="qa-wrap" data-id="56e19557e3433e1400422fee"><p> <strong class="question">What kind of graph is an example of an input used in a decision problem?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">arbitrary graph</span><span class="answer">arbitrary</span><span class="answer">arbitrary</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="56e19557e3433e1400422ff0"><p> <strong class="question">What is the term for the set of all connected graphs related to this decision problem?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">formal language</span><span class="answer">The formal language</span><span class="answer">The formal language associated with this decision problem</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="56e19557e3433e1400422ff1"><p> <strong class="question">What encoding decision needs to be made in order to determine an exact definition of the formal language?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">how graphs are encoded as binary strings</span><span class="answer">how graphs are encoded as binary strings</span><span class="answer">how graphs are encoded as binary strings</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad53d705b96ef001a10abd2"><p> <strong class="question">What type of graph is an example of an output used in a decision problem?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad53d705b96ef001a10abd3"><p> <strong class="question">What is the term for the set of all unconnected graphs related to this decision problem?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad53d705b96ef001a10abd4"><p> <strong class="question">What encoding decision needs to be made in order to determine an inaccurate definition of the formal language? </strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad53d705b96ef001a10abd5"><p> <strong class="question">How does one obtain an indefinite definition of this language?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div></div></div></div></div><div class="para-wrap"><div class="row"><div class="col-md-6"><pre>A function problem is a computational problem where a single output (of a total function) is expected for every input, but the output is more complex than that of a decision problem, that is, it isn't just yes or no. Notable examples include the traveling salesman problem and the integer factorization problem.</pre></div><div class="col-md-6"><div class="qas-wrap"><div class="qa-wrap" data-id="56e19724cd28a01900c679f6"><p> <strong class="question">A function problem is an example of what?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">a computational problem</span><span class="answer">a computational problem</span><span class="answer">a computational problem</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="56e19724cd28a01900c679f7"><p> <strong class="question">How many outputs are expected for each input in a function problem?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">a single output</span><span class="answer">single</span><span class="answer">single</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="56e19724cd28a01900c679f8"><p> <strong class="question">The traveling salesman problem is an example of what type of problem?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">A function problem</span><span class="answer">function</span><span class="answer">function problem</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="56e19724cd28a01900c679f9"><p> <strong class="question">In addition to the traveling salesman problem, what is another example of a function problem?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">the integer factorization problem</span><span class="answer">integer factorization</span><span class="answer">integer factorization problem</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="56e19724cd28a01900c679fa"><p> <strong class="question">Is the output of a functional problem typically characterized by a simple or complex answer?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">complex</span><span class="answer">complex</span><span class="answer">complex</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad53e615b96ef001a10abda"><p> <strong class="question">What is a computational solution where a single input is expected for every input?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad53e615b96ef001a10abdb"><p> <strong class="question">What is expected where a computational problems offers multiple outputs are expected for every input?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad53e615b96ef001a10abdc"><p> <strong class="question">What is a function solution an example of?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad53e615b96ef001a10abdd"><p> <strong class="question">What are other irrelevant examples of a function problem&gt;</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad53e615b96ef001a10abde"><p> <strong class="question">Is the output of a functional solution typically characterized by a simple or complex answer?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div></div></div></div></div><div class="para-wrap"><div class="row"><div class="col-md-6"><pre>It is tempting to think that the notion of function problems is much richer than the notion of decision problems. However, this is not really the case, since function problems can be recast as decision problems. For example, the multiplication of two integers can be expressed as the set of triples (a, b, c) such that the relation a × b = c holds. Deciding whether a given triple is a member of this set corresponds to solving the problem of multiplying two numbers.</pre></div><div class="col-md-6"><div class="qas-wrap"><div class="qa-wrap" data-id="56e1a0dccd28a01900c67a2e"><p> <strong class="question">How can function problems typically be restated?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">decision problems</span><span class="answer">as decision problems</span><span class="answer">as decision problems</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="56e1a0dccd28a01900c67a2f"><p> <strong class="question">If two integers are multiplied and output a value, what is this expression set called?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">set of triples</span><span class="answer">triple</span><span class="answer">the set of triples (a, b, c) such that the relation a × b = c holds</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad53f815b96ef001a10abe4"><p> <strong class="question">What can not be restated as decision problems?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad53f815b96ef001a10abe5"><p> <strong class="question">What is the expression set called where three integers are multiplied?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad53f815b96ef001a10abe6"><p> <strong class="question">What corresponds to solving the problem of multiplying three numbers/</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div></div></div></div></div><div class="para-wrap"><div class="row"><div class="col-md-6"><pre>To measure the difficulty of solving a computational problem, one may wish to see how much time the best algorithm requires to solve the problem. However, the running time may, in general, depend on the instance. In particular, larger instances will require more time to solve. Thus the time required to solve a problem (or the space required, or any measure of complexity) is calculated as a function of the size of the instance. This is usually taken to be the size of the input in bits. Complexity theory is interested in how algorithms scale with an increase in the input size. For instance, in the problem of finding whether a graph is connected, how much more time does it take to solve a problem for a graph with 2n vertices compared to the time taken for a graph with n vertices?</pre></div><div class="col-md-6"><div class="qas-wrap"><div class="qa-wrap" data-id="56e1a38de3433e140042305c"><p> <strong class="question">What is a commonly used measurement used to determine the complexity of a computational problem?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">how much time the best algorithm requires to solve the problem</span><span class="answer">time</span><span class="answer">time</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="56e1a38de3433e140042305d"><p> <strong class="question">What is one variable on which the running time may be contingent?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">the instance</span><span class="answer">the instance</span><span class="answer">the size of the instance</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="56e1a38de3433e140042305e"><p> <strong class="question">How is the time needed to obtain the solution to a problem calculated?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">as a function of the size of the instance</span><span class="answer">as a function of the size of the instance</span><span class="answer">a function of the size of the instance</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="56e1a38de3433e140042305f"><p> <strong class="question">In what unit is the size of the input measured?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">bits</span><span class="answer">bits</span><span class="answer">bits</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="56e1a38de3433e1400423060"><p> <strong class="question">Complexity theory seeks to define the relationship between the scale of algorithms with respect to what other variable?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">an increase in the input size</span><span class="answer">input size</span><span class="answer">input size</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad541ad5b96ef001a10abea"><p> <strong class="question">How does one measure the simplicity of a computational problem?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad541ad5b96ef001a10abeb"><p> <strong class="question">What is one variable which the running of time be not be contingent?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad541ad5b96ef001a10abec"><p> <strong class="question">How is the time needed to obtain the question to a problem calculated?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad541ad5b96ef001a10abed"><p> <strong class="question">What is  interested in how algorithms scale with a decrease in the input size?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad541ad5b96ef001a10abee"><p> <strong class="question">How is time not required to solve a problem calculated?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div></div></div></div></div><div class="para-wrap"><div class="row"><div class="col-md-6"><pre>If the input size is n, the time taken can be expressed as a function of n. Since the time taken on different inputs of the same size can be different, the worst-case time complexity T(n) is defined to be the maximum time taken over all inputs of size n. If T(n) is a polynomial in n, then the algorithm is said to be a polynomial time algorithm. Cobham's thesis says that a problem can be solved with a feasible amount of resources if it admits a polynomial time algorithm.</pre></div><div class="col-md-6"><div class="qas-wrap"><div class="qa-wrap" data-id="56e1a564cd28a01900c67a48"><p> <strong class="question">Whose thesis states that the solution to a problem is solvable with reasonable resources assuming it allows for a polynomial time algorithm?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">Cobham's thesis</span><span class="answer">Cobham's</span><span class="answer">Cobham</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="56e1a564cd28a01900c67a49"><p> <strong class="question">If input size is is equal to n, what can respectively be assumed is the function of n?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">the time taken</span><span class="answer">the time taken</span><span class="answer">the time taken</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="56e1a564cd28a01900c67a4a"><p> <strong class="question">What term corresponds to the maximum measurement of time across all functions of n? </strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">worst-case time complexity</span><span class="answer">worst-case time complexity</span><span class="answer">the worst-case time complexity</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="56e1a564cd28a01900c67a4b"><p> <strong class="question">How is worst-case time complexity written as an expression?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">T(n)</span><span class="answer">T(n)</span><span class="answer">T(n)</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="56e1a564cd28a01900c67a4c"><p> <strong class="question">Assuming that T represents a polynomial in T(n), what is the term given to the corresponding algorithm?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">polynomial time algorithm</span><span class="answer">polynomial time</span><span class="answer">polynomial time algorithm</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad542db5b96ef001a10abf4"><p> <strong class="question">How is time taken expressed as a function of x?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad542db5b96ef001a10abf5"><p> <strong class="question">Whose hypothesis states the the solution to a problem is solvable with reasonable resources assuming it allows for monoinomial time algorithm?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad542db5b96ef001a10abf6"><p> <strong class="question">What term corresponds to the minimum measurement of the time across all functions of n?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad542db5b96ef001a10abf7"><p> <strong class="question">How is best-case time complexity written as an expression?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad542db5b96ef001a10abf8"><p> <strong class="question">What is the term given to the corresponding algorithm assuming that T represents a mononominal in T(n)?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div></div></div></div></div><div class="para-wrap"><div class="row"><div class="col-md-6"><pre>A Turing machine is a mathematical model of a general computing machine. It is a theoretical device that manipulates symbols contained on a strip of tape. Turing machines are not intended as a practical computing technology, but rather as a thought experiment representing a computing machine—anything from an advanced supercomputer to a mathematician with a pencil and paper. It is believed that if a problem can be solved by an algorithm, there exists a Turing machine that solves the problem. Indeed, this is the statement of the Church–Turing thesis. Furthermore, it is known that everything that can be computed on other models of computation known to us today, such as a RAM machine, Conway's Game of Life, cellular automata or any programming language can be computed on a Turing machine. Since Turing machines are easy to analyze mathematically, and are believed to be as powerful as any other model of computation, the Turing machine is the most commonly used model in complexity theory.</pre></div><div class="col-md-6"><div class="qas-wrap"><div class="qa-wrap" data-id="56e1aba0e3433e1400423094"><p> <strong class="question">What is the term for a mathematical model that theoretically represents a general computing machine?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">A Turing machine</span><span class="answer">A Turing machine</span><span class="answer">Turing machine</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="56e1aba0e3433e1400423095"><p> <strong class="question">It is generally assumed that a Turing machine can solve anything capable of also being solved using what?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">an algorithm</span><span class="answer">an algorithm</span><span class="answer">an algorithm</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="56e1aba0e3433e1400423097"><p> <strong class="question">What is the most commonplace model utilized in complexity theory?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">the Turing machine</span><span class="answer">the Turing machine</span><span class="answer">Turing machine</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="56e1aba0e3433e1400423098"><p> <strong class="question">What does a Turing machine handle on a strip of tape?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">symbols</span><span class="answer">symbols</span><span class="answer">symbols</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad543c05b96ef001a10abfe"><p> <strong class="question">What a scientific model of a general computing machine?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad543c05b96ef001a10abff"><p> <strong class="question">What is a scientific device that manipulates symbols contained on a strip of tape?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad543c05b96ef001a10ac00"><p> <strong class="question">What are intended as a practical computing technology?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad543c05b96ef001a10ac01"><p> <strong class="question">What is a scientific experiment that can solve a problem by algorithms?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div></div></div></div></div><div class="para-wrap"><div class="row"><div class="col-md-6"><pre>A deterministic Turing machine is the most basic Turing machine, which uses a fixed set of rules to determine its future actions. A probabilistic Turing machine is a deterministic Turing machine with an extra supply of random bits. The ability to make probabilistic decisions often helps algorithms solve problems more efficiently. Algorithms that use random bits are called randomized algorithms. A non-deterministic Turing machine is a deterministic Turing machine with an added feature of non-determinism, which allows a Turing machine to have multiple possible future actions from a given state. One way to view non-determinism is that the Turing machine branches into many possible computational paths at each step, and if it solves the problem in any of these branches, it is said to have solved the problem. Clearly, this model is not meant to be a physically realizable model, it is just a theoretically interesting abstract machine that gives rise to particularly interesting complexity classes. For examples, see non-deterministic algorithm.</pre></div><div class="col-md-6"><div class="qas-wrap"><div class="qa-wrap" data-id="56e1aff7cd28a01900c67a68"><p> <strong class="question">What is generally considered to be the most basic iteration of a Turing machine?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">A deterministic Turing machine</span><span class="answer">deterministic</span><span class="answer">deterministic Turing machine</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="56e1aff7cd28a01900c67a69"><p> <strong class="question">What fixed set of factors determine the actions of a deterministic Turing machine</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">rules</span><span class="answer">rules</span><span class="answer">a fixed set of rules to determine its future actions</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="56e1aff7cd28a01900c67a6a"><p> <strong class="question">What is the term used to identify a deterministic Turing machine that has additional random bits?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">A probabilistic Turing machine</span><span class="answer">probabilistic</span><span class="answer">probabilistic Turing machine</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="56e1aff7cd28a01900c67a6b"><p> <strong class="question">What type of Turing machine is capable of multiple actions and extends into a variety of computational paths?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">A non-deterministic Turing machine</span><span class="answer">non-deterministic</span><span class="answer">non-deterministic Turing machine</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="56e1aff7cd28a01900c67a6c"><p> <strong class="question">What is the term given to algorithms that utilize random bits?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">randomized algorithms</span><span class="answer">randomized algorithms</span><span class="answer">randomized algorithms</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad546c75b96ef001a10ac0e"><p> <strong class="question">What uses a flexible set of rules to determine its future actions?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad546c75b96ef001a10ac0f"><p> <strong class="question">What is a deterministic Turing machine with an extra supply of random ribbons?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad546c75b96ef001a10ac10"><p> <strong class="question">What does not often help algorithms solve problems more efficiently?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad546c75b96ef001a10ac11"><p> <strong class="question">Which machine allows the machine to have multiple possible past actions from a given state?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad546c75b96ef001a10ac12"><p> <strong class="question">How is one way that one should not view non-determinism?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div></div></div></div></div><div class="para-wrap"><div class="row"><div class="col-md-6"><pre>Many types of Turing machines are used to define complexity classes, such as deterministic Turing machines, probabilistic Turing machines, non-deterministic Turing machines, quantum Turing machines, symmetric Turing machines and alternating Turing machines. They are all equally powerful in principle, but when resources (such as time or space) are bounded, some of these may be more powerful than others.</pre></div><div class="col-md-6"><div class="qas-wrap"><div class="qa-wrap" data-id="56e1b00ce3433e140042309e"><p> <strong class="question">Turing machines are commonly employed to define what? </strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">complexity classes</span><span class="answer">complexity classes</span><span class="answer">complexity classes</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="56e1b00ce3433e140042309f"><p> <strong class="question">What are two factors that directly effect how powerful a Turing machine may or may not be?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">time or space</span><span class="answer">time or space</span><span class="answer">time or space</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="56e1b00ce3433e14004230a1"><p> <strong class="question">In the determination of complexity classes, what are two examples of types of Turing machines?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">probabilistic Turing machines, non-deterministic Turing machines</span><span class="answer">probabilistic Turing machines, non-deterministic Turing machines</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad545545b96ef001a10ac06"><p> <strong class="question">What are many types of Turing machines not used for?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad545545b96ef001a10ac07"><p> <strong class="question">What are three factors that directly effect how powerful a Turing machine may or may not be?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad545545b96ef001a10ac08"><p> <strong class="question">What machines are not equally powerful in principle?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad545545b96ef001a10ac09"><p> <strong class="question">What may not be more powerful than others when the resources of time or space of considered?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div></div></div></div></div><div class="para-wrap"><div class="row"><div class="col-md-6"><pre>Many machine models different from the standard multi-tape Turing machines have been proposed in the literature, for example random access machines. Perhaps surprisingly, each of these models can be converted to another without providing any extra computational power. The time and memory consumption of these alternate models may vary. What all these models have in common is that the machines operate deterministically.</pre></div><div class="col-md-6"><div class="qas-wrap"><div class="qa-wrap" data-id="56e1b169cd28a01900c67a72"><p> <strong class="question">What is an example of a machine model that deviates from a generally accepted multi-tape Turing machine?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">random access machines</span><span class="answer">random access machines</span><span class="answer">random access machines</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="56e1b169cd28a01900c67a73"><p> <strong class="question">In considering Turing machines and alternate variables, what measurement left unaffected by conversion between machine models? </strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">computational power</span><span class="answer">computational power</span><span class="answer">computational power</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="56e1b169cd28a01900c67a74"><p> <strong class="question">What two resources commonly consumed by alternate models are typically known to vary?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">time and memory</span><span class="answer">time and memory consumption</span><span class="answer">time and memory consumption</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="56e1b169cd28a01900c67a75"><p> <strong class="question">What commonality do alternate machine models, such as random access machines, share with Turing machines?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">the machines operate deterministically</span><span class="answer">deterministically</span><span class="answer">the machines operate deterministically</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad547945b96ef001a10ac18"><p> <strong class="question">What is not an example of a machine model that deviates from a generally accepted multi-tape Turing machine?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad547945b96ef001a10ac19"><p> <strong class="question">What measurement is affected by conversion between machine models?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad547945b96ef001a10ac1a"><p> <strong class="question">What two resources are uncommonly consumed by alternate models and are typically known to vary?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad547945b96ef001a10ac1b"><p> <strong class="question">What do all these models not have in common?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div></div></div></div></div><div class="para-wrap"><div class="row"><div class="col-md-6"><pre>However, some computational problems are easier to analyze in terms of more unusual resources. For example, a non-deterministic Turing machine is a computational model that is allowed to branch out to check many different possibilities at once. The non-deterministic Turing machine has very little to do with how we physically want to compute algorithms, but its branching exactly captures many of the mathematical models we want to analyze, so that non-deterministic time is a very important resource in analyzing computational problems.</pre></div><div class="col-md-6"><div class="qas-wrap"><div class="qa-wrap" data-id="56e1b355e3433e14004230b0"><p> <strong class="question">What type of Turing machine can be characterized by checking multiple possibilities at the same time?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">non-deterministic</span><span class="answer">non-deterministic</span><span class="answer">non-deterministic Turing machine</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="56e1b355e3433e14004230b1"><p> <strong class="question">What often affects or facilitates ease of analysis in computational problems?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">unusual resources</span><span class="answer">more unusual resources</span><span class="answer">more unusual resources</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="56e1b355e3433e14004230b2"><p> <strong class="question">A non-deterministic Turing machine has the ability to capture what facet of useful analysis?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">mathematical models</span><span class="answer">mathematical models</span><span class="answer">branching</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="56e1b355e3433e14004230b3"><p> <strong class="question">What is the most critical resource in the analysis of computational problems associated with non-deterministic Turing machines?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">time</span><span class="answer">non-deterministic time</span><span class="answer">non-deterministic time</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad5489b5b96ef001a10ac2a"><p> <strong class="question">What is harder to analyze in terms of more unusual resources?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad5489b5b96ef001a10ac2b"><p> <strong class="question">What type of machine is a computational model that is not allowed to branch out to check many different possibilities at once?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad5489b5b96ef001a10ac2c"><p> <strong class="question">What has a lot to do with how we physically want to compute algorithms?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad5489b5b96ef001a10ac2d"><p> <strong class="question">What machine's branching does not exactly capture many of the mathematical models we want to analyze?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad5489b5b96ef001a10ac2e"><p> <strong class="question">What is the least critical resource in the analysis of computational problems associated with non-deterministic Turing machines?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div></div></div></div></div><div class="para-wrap"><div class="row"><div class="col-md-6"><pre>For a precise definition of what it means to solve a problem using a given amount of time and space, a computational model such as the deterministic Turing machine is used. The time required by a deterministic Turing machine M on input x is the total number of state transitions, or steps, the machine makes before it halts and outputs the answer (&quot;yes&quot; or &quot;no&quot;). A Turing machine M is said to operate within time f(n), if the time required by M on each input of length n is at most f(n). A decision problem A can be solved in time f(n) if there exists a Turing machine operating in time f(n) that solves the problem. Since complexity theory is interested in classifying problems based on their difficulty, one defines sets of problems based on some criteria. For instance, the set of problems solvable within time f(n) on a deterministic Turing machine is then denoted by DTIME(f(n)).</pre></div><div class="col-md-6"><div class="qas-wrap"><div class="qa-wrap" data-id="56e1b62ecd28a01900c67aa3"><p> <strong class="question">The time required to output an answer on a deterministic Turing machine is expressed as what?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">state transitions</span><span class="answer">the total number of state transitions, or steps</span><span class="answer">total number of state transitions, or steps, the machine makes before it halts and outputs the answer</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="56e1b62ecd28a01900c67aa4"><p> <strong class="question">Complexity theory classifies problems based on what primary attribute?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">difficulty</span><span class="answer">difficulty</span><span class="answer">difficulty</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="56e1b62ecd28a01900c67aa5"><p> <strong class="question">What is the expression used to identify any given series of problems capable of being solved within time on a deterministic Turing machine?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">DTIME(f(n))</span><span class="answer">DTIME(f(n)).</span><span class="answer">DTIME(f(n))</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="56e1b62ecd28a01900c67aa6"><p> <strong class="question">What is the most critical resource measured to in assessing the determination of a Turing machine's ability to solve any given set of problems?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">time</span><span class="answer">time</span><span class="answer">time</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad54a375b96ef001a10ac48"><p> <strong class="question">What is not used for a precise definition of what it means to solve a problem using a given amount of time and space?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad54a375b96ef001a10ac49"><p> <strong class="question">How is Turing machine M said not to operate?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad54a375b96ef001a10ac4a"><p> <strong class="question">What is the expression used to identify any given series of solutions capable of being solved within time on a deterministic Turing machine?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad54a375b96ef001a10ac4b"><p> <strong class="question">What is the least critical resource measured in assessing the determination of a Turing machine's ability to solve any given set of problems?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad54a375b96ef001a10ac4c"><p> <strong class="question">How can decision problem B be solved in time x(f)?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div></div></div></div></div><div class="para-wrap"><div class="row"><div class="col-md-6"><pre>Analogous definitions can be made for space requirements. Although time and space are the most well-known complexity resources, any complexity measure can be viewed as a computational resource. Complexity measures are very generally defined by the Blum complexity axioms. Other complexity measures used in complexity theory include communication complexity, circuit complexity, and decision tree complexity.</pre></div><div class="col-md-6"><div class="qas-wrap"><div class="qa-wrap" data-id="56e1b754cd28a01900c67abc"><p> <strong class="question">Time and space are both examples of what type of resource?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">complexity resources</span><span class="answer">complexity resources</span><span class="answer">complexity</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="56e1b754cd28a01900c67abd"><p> <strong class="question">A complexity resource can also be described as what other type of resource?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">computational resource</span><span class="answer">computational</span><span class="answer">computational</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="56e1b754cd28a01900c67abe"><p> <strong class="question">What is typically used to broadly define complexity measures?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">Blum complexity axioms</span><span class="answer">the Blum complexity axioms</span><span class="answer">the Blum complexity axioms</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="56e1b754cd28a01900c67abf"><p> <strong class="question">Communication complexity is an example of what type of measure?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">Complexity measures</span><span class="answer">complexity measures</span><span class="answer">complexity</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="56e1b754cd28a01900c67ac0"><p> <strong class="question">Decision tree is an example of what type of measure?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">Complexity measures</span><span class="answer">complexity measures</span><span class="answer">complexity</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad54b035b96ef001a10ac52"><p> <strong class="question">What can not be made for space requirements?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad54b035b96ef001a10ac53"><p> <strong class="question">What are the least well known complexity resources?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad54b035b96ef001a10ac54"><p> <strong class="question">How are complexity measures generally not defined?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad54b035b96ef001a10ac55"><p> <strong class="question">What are other complexity measures not used in complexity theory?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad54b035b96ef001a10ac56"><p> <strong class="question">What type of measure is communication complexity not an example of?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div></div></div></div></div><div class="para-wrap"><div class="row"><div class="col-md-6"><pre>The best, worst and average case complexity refer to three different ways of measuring the time complexity (or any other complexity measure) of different inputs of the same size. Since some inputs of size n may be faster to solve than others, we define the following complexities:</pre></div><div class="col-md-6"><div class="qas-wrap"><div class="qa-wrap" data-id="56e1b8f3e3433e14004230e6"><p> <strong class="question">What are the three primary expressions used to represent case complexity?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">best, worst and average</span><span class="answer">best, worst and average case</span><span class="answer">best, worst and average case complexity</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="56e1b8f3e3433e14004230e7"><p> <strong class="question">Case complexity likelihoods provide variable probabilities of what general measure? </strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">complexity measure</span><span class="answer">complexity</span><span class="answer">complexity</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="56e1b8f3e3433e14004230e8"><p> <strong class="question">What is one common example of a critical complexity measure?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">time</span><span class="answer">time complexity</span><span class="answer">time complexity</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="56e1b8f3e3433e14004230e9"><p> <strong class="question">Case complexities provide three likelihoods of what differing variable that remains the same size? </strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">inputs</span><span class="answer">inputs</span><span class="answer">inputs</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad54c2f5b96ef001a10ac5c"><p> <strong class="question">What are the three secondary expressions used to represent case complexity? </strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad54c2f5b96ef001a10ac5d"><p> <strong class="question">What three different ways are used to measure space complexity?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad54c2f5b96ef001a10ac5e"><p> <strong class="question">What is one not common example of a critical complexity measure?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad54c2f5b96ef001a10ac5f"><p> <strong class="question">What differing variable remains the same size when providing the four likelihoods of case complexities?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div></div></div></div></div><div class="para-wrap"><div class="row"><div class="col-md-6"><pre>For example, consider the deterministic sorting algorithm quicksort. This solves the problem of sorting a list of integers that is given as the input. The worst-case is when the input is sorted or sorted in reverse order, and the algorithm takes time O(n2) for this case. If we assume that all possible permutations of the input list are equally likely, the average time taken for sorting is O(n log n). The best case occurs when each pivoting divides the list in half, also needing O(n log n) time.</pre></div><div class="col-md-6"><div class="qas-wrap"><div class="qa-wrap" data-id="56e1ba41cd28a01900c67ae0"><p> <strong class="question">What provides a solution to a list of integers provided as input that ned to be sorted?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">deterministic sorting algorithm quicksort</span><span class="answer">quicksort</span><span class="answer">the deterministic sorting algorithm quicksort</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="56e1ba41cd28a01900c67ae1"><p> <strong class="question">When extensive time is required to sort integers, this represents what case complexity?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">worst-case</span><span class="answer">worst</span><span class="answer">worst-case</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="56e1ba41cd28a01900c67ae2"><p> <strong class="question">What is the expression used to denote a worst case complexity as expressed by time taken?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">O(n2)</span><span class="answer">O(n2)</span><span class="answer">O(n2)</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad54d625b96ef001a10ac64"><p> <strong class="question">What does not solve the problem of sorting a list of integers that is given as the input?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad54d625b96ef001a10ac65"><p> <strong class="question">What does the deterministic parting algorithm quicksort do?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad54d625b96ef001a10ac66"><p> <strong class="question">What case complexity is represented when limited time is required to sort integers?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad54d625b96ef001a10ac67"><p> <strong class="question">What is the expression not used to denote worst case complexity as expressed by time taken?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad54d625b96ef001a10ac68"><p> <strong class="question">What case complexity is represented when each pivoting divides the list in thirds, also needing O(n log n) time?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div></div></div></div></div><div class="para-wrap"><div class="row"><div class="col-md-6"><pre>To classify the computation time (or similar resources, such as space consumption), one is interested in proving upper and lower bounds on the minimum amount of time required by the most efficient algorithm solving a given problem. The complexity of an algorithm is usually taken to be its worst-case complexity, unless specified otherwise. Analyzing a particular algorithm falls under the field of analysis of algorithms. To show an upper bound T(n) on the time complexity of a problem, one needs to show only that there is a particular algorithm with running time at most T(n). However, proving lower bounds is much more difficult, since lower bounds make a statement about all possible algorithms that solve a given problem. The phrase &quot;all possible algorithms&quot; includes not just the algorithms known today, but any algorithm that might be discovered in the future. To show a lower bound of T(n) for a problem requires showing that no algorithm can have time complexity lower than T(n).</pre></div><div class="col-md-6"><div class="qas-wrap"><div class="qa-wrap" data-id="56e1bc3ae3433e1400423104"><p> <strong class="question">Classification of resources is contingent on determining the upper and lower bounds of minimum time required by what?  </strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">the most efficient algorithm</span><span class="answer">the most efficient algorithm</span><span class="answer">the most efficient algorithm solving a given problem</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="56e1bc3ae3433e1400423105"><p> <strong class="question">The analysis of a specific algorithm is typically assigned to what field of computational science?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">analysis of algorithms</span><span class="answer">analysis of algorithms</span><span class="answer">analysis of algorithms</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="56e1bc3ae3433e1400423106"><p> <strong class="question">Which bound of time is more difficult to establish?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">lower bounds</span><span class="answer">lower</span><span class="answer">lower bounds</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="56e1bc3ae3433e1400423107"><p> <strong class="question">A specific algorithm demonstrating T(n) represents what measure of time complexity?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">upper bound</span><span class="answer">upper and lower bounds</span><span class="answer">upper bound</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="56e1bc3ae3433e1400423108"><p> <strong class="question">What is the colloquial phrase used to convey the continuum of algorithms with unlimited availability irrespective of time? </strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">all possible algorithms</span><span class="answer">all possible algorithms</span><span class="answer">all possible algorithms</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad54e7c5b96ef001a10ac76"><p> <strong class="question">How does one note classify the computation time (or similar resources)?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad54e7c5b96ef001a10ac77"><p> <strong class="question">What is usually taken as the best case complexity, unless specified otherwise?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad54e7c5b96ef001a10ac78"><p> <strong class="question">What does not fall under the field of analysis of algorithms&gt;</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad54e7c5b96ef001a10ac79"><p> <strong class="question">When does one not need to show only that there is a particular algorithm running time at mons T(nO?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad54e7c5b96ef001a10ac7a"><p> <strong class="question">What is easy about proving lower bounds?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div></div></div></div></div><div class="para-wrap"><div class="row"><div class="col-md-6"><pre>Upper and lower bounds are usually stated using the big O notation, which hides constant factors and smaller terms. This makes the bounds independent of the specific details of the computational model used. For instance, if T(n) = 7n2 + 15n + 40, in big O notation one would write T(n) = O(n2).</pre></div><div class="col-md-6"><div class="qas-wrap"><div class="qa-wrap" data-id="56e1bd4acd28a01900c67afc"><p> <strong class="question">What expression is generally used to convey upper or lower bounds?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">big O notation</span><span class="answer">big O notation</span><span class="answer">big O notation</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="56e1bd4acd28a01900c67afd"><p> <strong class="question">What does a big O notation hide?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">constant factors and smaller terms</span><span class="answer">constant factors and smaller terms</span><span class="answer">constant factors and smaller terms</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="56e1bd4acd28a01900c67afe"><p> <strong class="question">How would one write T(n) = 7n2 + 15n + 40 in big O notation? </strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">T(n) = O(n2)</span><span class="answer">T(n) = O(n2)</span><span class="answer">T(n) = O(n2)</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="56e1bd4acd28a01900c67aff"><p> <strong class="question">Big O notation provides autonomy to upper and lower bounds with relationship to what? </strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">the computational model</span><span class="answer">specific details of the computational model used</span><span class="answer">the specific details of the computational model used</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad54f775b96ef001a10ac88"><p> <strong class="question">What is usually not stated using the big O notation?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad54f775b96ef001a10ac89"><p> <strong class="question">What does not hide constant factors or smaller terms?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad54f775b96ef001a10ac8a"><p> <strong class="question">What makes the bounds dependent of the specific details of the computational model?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad54f775b96ef001a10ac8b"><p> <strong class="question">How would one abbreviate T(n)=8n2 + 16n = 40 in big O notatation?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div></div></div></div></div><div class="para-wrap"><div class="row"><div class="col-md-6"><pre>Of course, some complexity classes have complicated definitions that do not fit into this framework. Thus, a typical complexity class has a definition like the following:</pre></div><div class="col-md-6"><div class="qas-wrap"><div class="qa-wrap" data-id="56e1c0f6cd28a01900c67b2c"><p> <strong class="question">What has complicated definitions that prevent classification into a framework?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">complexity classes</span><span class="answer">complexity classes</span><span class="answer">some complexity classes</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="56e1c0f6cd28a01900c67b2d"><p> <strong class="question">Complexity classes are generally classified into what?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">framework</span><span class="answer">framework</span><span class="answer">framework</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="56e1c0f6cd28a01900c67b2e"><p> <strong class="question">Difficulty in establishing a framework for complexity classes can be caused by what variable?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">complicated definitions</span><span class="answer">complicated definitions</span><span class="answer">definitions</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad5501f5b96ef001a10ac90"><p> <strong class="question">What fits the framework of complexity classes?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad5501f5b96ef001a10ac91"><p> <strong class="question">What has uncomplicated definitions that prevent classification into a framework?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad5501f5b96ef001a10ac92"><p> <strong class="question">What are complexity classes generally not classified into?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad5501f5b96ef001a10ac93"><p> <strong class="question">What variable is easy to establish in a framework for complexity classes?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div></div></div></div></div><div class="para-wrap"><div class="row"><div class="col-md-6"><pre>But bounding the computation time above by some concrete function f(n) often yields complexity classes that depend on the chosen machine model. For instance, the language {xx | x is any binary string} can be solved in linear time on a multi-tape Turing machine, but necessarily requires quadratic time in the model of single-tape Turing machines. If we allow polynomial variations in running time, Cobham-Edmonds thesis states that &quot;the time complexities in any two reasonable and general models of computation are polynomially related&quot; (Goldreich 2008, Chapter 1.2). This forms the basis for the complexity class P, which is the set of decision problems solvable by a deterministic Turing machine within polynomial time. The corresponding set of function problems is FP.</pre></div><div class="col-md-6"><div class="qas-wrap"><div class="qa-wrap" data-id="56e1c2eee3433e1400423134"><p> <strong class="question">Concrete bounding of computation time frequently produces complexity classes contingent upon what?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">chosen machine model</span><span class="answer">the chosen machine model</span><span class="answer">the chosen machine model</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="56e1c2eee3433e1400423135"><p> <strong class="question">A multi-tape Turing machine requires what type of time for a solution?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">linear time</span><span class="answer">linear</span><span class="answer">linear</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="56e1c2eee3433e1400423136"><p> <strong class="question">A language solved in quadratic time implies the use of what type of Turing machine?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">single-tape Turing machines</span><span class="answer">single-tape</span><span class="answer">single-tape</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="56e1c2eee3433e1400423137"><p> <strong class="question">What thesis specifies that a polynomial relationship exists within time complexities in a computational model? </strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">Cobham-Edmonds thesis</span><span class="answer">Cobham-Edmonds</span><span class="answer">Cobham-Edmonds thesis</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="56e1c2eee3433e1400423138"><p> <strong class="question">Decision problems capable of being solved by a deterministic Turing machine while maintaining adherence to polynomial time belong to what class?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">complexity class P</span><span class="answer">P</span><span class="answer">complexity class P</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad55ee35b96ef001a10ace4"><p> <strong class="question">What does not often yield complexity classes that depend on the chosen machine model?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad55ee35b96ef001a10ace5"><p> <strong class="question">What does not frequently produce complexity classes that have concrete bounding of computation time?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad55ee35b96ef001a10ace6"><p> <strong class="question">What can not be solved in linear time on multi-tape Turing machine?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad55ee35b96ef001a10ace7"><p> <strong class="question">What is not a binary string?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad55ee35b96ef001a10ace8"><p> <strong class="question">What thesis specifies that a trinomial relationship exists within time complexities in a computational model?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div></div></div></div></div><div class="para-wrap"><div class="row"><div class="col-md-6"><pre>Many important complexity classes can be defined by bounding the time or space used by the algorithm. Some important complexity classes of decision problems defined in this manner are the following:</pre></div><div class="col-md-6"><div class="qas-wrap"><div class="qa-wrap" data-id="56e1c3e1e3433e1400423148"><p> <strong class="question">What are two examples of measurements are bound within algorithms to establish complexity classes?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">time or space</span><span class="answer">time or space</span><span class="answer">time or space</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="56e1c3e1e3433e1400423149"><p> <strong class="question">What function is used by algorithms to define measurements like time or space?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">bounding</span><span class="answer">bounding</span><span class="answer">bounding</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="56e1c3e1e3433e140042314a"><p> <strong class="question">Bounding of time and space or similar measurements is often used by algorithms to define what?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">complexity classes</span><span class="answer">complexity classes</span><span class="answer">complexity classes</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad55fe75b96ef001a10ad0c"><p> <strong class="question">What cannot be defined by bounding the time or space used the the algorithm?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad55fe75b96ef001a10ad0d"><p> <strong class="question">What are three examples of measurement that are bound within algorithms to establish complexity classes?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad55fe75b96ef001a10ad0e"><p> <strong class="question">What function is used by algorithms to define measurements like time and numbers?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad55fe75b96ef001a10ad0f"><p> <strong class="question">What is often used by algorithms to measure bounding of space and atmosphere measurements?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div></div></div></div></div><div class="para-wrap"><div class="row"><div class="col-md-6"><pre>Other important complexity classes include BPP, ZPP and RP, which are defined using probabilistic Turing machines; AC and NC, which are defined using Boolean circuits; and BQP and QMA, which are defined using quantum Turing machines. #P is an important complexity class of counting problems (not decision problems). Classes like IP and AM are defined using Interactive proof systems. ALL is the class of all decision problems.</pre></div><div class="col-md-6"><div class="qas-wrap"><div class="qa-wrap" data-id="56e1c4fce3433e140042314e"><p> <strong class="question">What are three examples of complexity classes associated with definitions established by probabilistic Turing machines?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">BPP, ZPP and RP</span><span class="answer">BPP, ZPP and RP</span><span class="answer">BPP, ZPP and RP</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="56e1c4fce3433e140042314f"><p> <strong class="question">AC and NC are complexity classes typically associated with what type of circuit?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">Boolean</span><span class="answer">Boolean</span><span class="answer">Boolean circuits;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="56e1c4fce3433e1400423150"><p> <strong class="question">BQP and QMA are examples of complexity classes most commonly associated with what type of Turing machine?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">quantum</span><span class="answer">quantum</span><span class="answer">quantum</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="56e1c4fce3433e1400423151"><p> <strong class="question">What is the expression used to represent a complexity class of counting problems?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">#P</span><span class="answer">#P</span><span class="answer">#P</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="56e1c4fce3433e1400423152"><p> <strong class="question">IP and AM are most commonly defined by what type of proof system?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">Interactive</span><span class="answer">Interactive</span><span class="answer">Interactive</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad560b85b96ef001a10ad1e"><p> <strong class="question">What are the other four important complexity classes?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad560b85b96ef001a10ad1f"><p> <strong class="question">What machine does not define BPP, ZPP, and RP?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad560b85b96ef001a10ad20"><p> <strong class="question">What machine does not define BQP or QMA?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad560b85b96ef001a10ad21"><p> <strong class="question">What is least important complexity class of counting problems?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad560b85b96ef001a10ad22"><p> <strong class="question">What system not often define classes like IP and AM/</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div></div></div></div></div><div class="para-wrap"><div class="row"><div class="col-md-6"><pre>For the complexity classes defined in this way, it is desirable to prove that relaxing the requirements on (say) computation time indeed defines a bigger set of problems. In particular, although DTIME(n) is contained in DTIME(n2), it would be interesting to know if the inclusion is strict. For time and space requirements, the answer to such questions is given by the time and space hierarchy theorems respectively. They are called hierarchy theorems because they induce a proper hierarchy on the classes defined by constraining the respective resources. Thus there are pairs of complexity classes such that one is properly included in the other. Having deduced such proper set inclusions, we can proceed to make quantitative statements about how much more additional time or space is needed in order to increase the number of problems that can be solved.</pre></div><div class="col-md-6"><div class="qas-wrap"><div class="qa-wrap" data-id="56e1c720e3433e140042316a"><p> <strong class="question">What is an example of a measurement within a complexity class that would create a bigger set of problems if the bounds were relaxed?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">computation time</span><span class="answer">computation time</span><span class="answer">computation time</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="56e1c720e3433e140042316b"><p> <strong class="question">In what expression can one expect to find DTIME(n)</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">DTIME(n2)</span><span class="answer">DTIME(n2)</span><span class="answer">DTIME(n2)</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="56e1c720e3433e140042316c"><p> <strong class="question">What theorems are responsible for determining questions of time and space requirements?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">time and space hierarchy theorems</span><span class="answer">time and space hierarchy theorems</span><span class="answer">time and space hierarchy theorems</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="56e1c720e3433e140042316d"><p> <strong class="question">Resources are constrained by hierarchy theorems to produce what?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">a proper hierarchy on the classes defined</span><span class="answer">a proper hierarchy on the classes</span><span class="answer">a proper hierarchy</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="56e1c720e3433e140042316e"><p> <strong class="question">What kind of statement is made in the effort of establishing the time and space requirements needed to enhance the ultimate number of problems solved?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">quantitative statements</span><span class="answer">quantitative</span><span class="answer">quantitative</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad561c85b96ef001a10ad3c"><p> <strong class="question">What is not an example of a measurement within a complexity class that would create a bigger set of problems if the bounds were relaxed?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad561c85b96ef001a10ad3d"><p> <strong class="question">What does not define a bigger set of problems?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad561c85b96ef001a10ad3e"><p> <strong class="question">What expression does not usually contain DTIME(n)?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad561c85b96ef001a10ad3f"><p> <strong class="question">What does not induce a proper hierarchy on the classes defined by constraining the respective resources?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad561c85b96ef001a10ad40"><p> <strong class="question">What kind of statement is not made in an effort of establishing the time and space requirements needed to enhance the ultimate number of problems solved?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div></div></div></div></div><div class="para-wrap"><div class="row"><div class="col-md-6"><pre>The time and space hierarchy theorems form the basis for most separation results of complexity classes. For instance, the time hierarchy theorem tells us that P is strictly contained in EXPTIME, and the space hierarchy theorem tells us that L is strictly contained in PSPACE.</pre></div><div class="col-md-6"><div class="qas-wrap"><div class="qa-wrap" data-id="56e1c7e2cd28a01900c67b74"><p> <strong class="question">What is the foundation for separation results within complexity classes?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">time and space hierarchy theorems</span><span class="answer">The time and space hierarchy theorems</span><span class="answer">time and space hierarchy theorems</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="56e1c7e2cd28a01900c67b75"><p> <strong class="question">What is responsible for constraining P according to the time hierarchy theorem?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">EXPTIME</span><span class="answer">EXPTIME</span><span class="answer">EXPTIME</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="56e1c7e2cd28a01900c67b76"><p> <strong class="question">Within what variable is L constrained according to the space hierarchy theorem?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">PSPACE</span><span class="answer">PSPACE</span><span class="answer">PSPACE</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad562525b96ef001a10ad50"><p> <strong class="question">What does not form the basis for most separation results of complexity classes?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad562525b96ef001a10ad51"><p> <strong class="question">What does the past time and space hierarchy theorems form the basis of?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad562525b96ef001a10ad52"><p> <strong class="question">What is not strictly contained in EXPTIME?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad562525b96ef001a10ad53"><p> <strong class="question">What is not strictly contained in PSPACE?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div></div></div></div></div><div class="para-wrap"><div class="row"><div class="col-md-6"><pre>Many complexity classes are defined using the concept of a reduction. A reduction is a transformation of one problem into another problem. It captures the informal notion of a problem being at least as difficult as another problem. For instance, if a problem X can be solved using an algorithm for Y, X is no more difficult than Y, and we say that X reduces to Y. There are many different types of reductions, based on the method of reduction, such as Cook reductions, Karp reductions and Levin reductions, and the bound on the complexity of reductions, such as polynomial-time reductions or log-space reductions.</pre></div><div class="col-md-6"><div class="qas-wrap"><div class="qa-wrap" data-id="56e1c9bfe3433e1400423192"><p> <strong class="question">What concept is frequently used to define complexity classes?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">reduction</span><span class="answer">a reduction</span><span class="answer">reduction</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="56e1c9bfe3433e1400423193"><p> <strong class="question">Reduction essentially takes one problem and converts into what?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">another problem</span><span class="answer">another problem</span><span class="answer">another problem</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="56e1c9bfe3433e1400423194"><p> <strong class="question">According to reduction, if X and Y can be solved by the same algorithm then X performs what function in relationship to Y?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">reduces</span><span class="answer">reduces</span><span class="answer">X reduces to Y</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="56e1c9bfe3433e1400423195"><p> <strong class="question">What are two examples of different types of reduction?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">Karp reductions and Levin reductions</span><span class="answer">Cook reductions, Karp reductions</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="56e1c9bfe3433e1400423196"><p> <strong class="question">Polynomial time reductions are an example of what?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">the bound on the complexity of reductions</span><span class="answer">types of reductions</span><span class="answer">the bound on the complexity of reductions</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad5632f5b96ef001a10ad6c"><p> <strong class="question">What are many complexity classes not defined by?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad5632f5b96ef001a10ad6d"><p> <strong class="question">What is defined by using the theorem of reduction?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad5632f5b96ef001a10ad6e"><p> <strong class="question">What is a transformation of two problems into on three problems?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad5632f5b96ef001a10ad6f"><p> <strong class="question">What captures the formal notion of a problem being at lease as difficult as another problem?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad5632f5b96ef001a10ad70"><p> <strong class="question">What are the six types of reductions?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div></div></div></div></div><div class="para-wrap"><div class="row"><div class="col-md-6"><pre>The most commonly used reduction is a polynomial-time reduction. This means that the reduction process takes polynomial time. For example, the problem of squaring an integer can be reduced to the problem of multiplying two integers. This means an algorithm for multiplying two integers can be used to square an integer. Indeed, this can be done by giving the same input to both inputs of the multiplication algorithm. Thus we see that squaring is not more difficult than multiplication, since squaring can be reduced to multiplication.</pre></div><div class="col-md-6"><div class="qas-wrap"><div class="qa-wrap" data-id="56e1cbe2cd28a01900c67bac"><p> <strong class="question">What is the most frequently employed type of reduction?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">polynomial-time reduction</span><span class="answer">polynomial-time</span><span class="answer">polynomial-time reduction</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="56e1cbe2cd28a01900c67bad"><p> <strong class="question">What equates to a squared integer according to polynomial time reduction?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">multiplying two integers</span><span class="answer">multiplying two integers</span><span class="answer">multiplying two integers</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="56e1cbe2cd28a01900c67bae"><p> <strong class="question">What measurement of time is used in polynomial time reduction?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">polynomial time</span><span class="answer">polynomial</span><span class="answer">polynomial time</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="56e1cbe2cd28a01900c67baf"><p> <strong class="question">What would need to remain constant in a multiplication algorithm to produce the same outcome whether multiplying or squaring two integers?  </strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">input</span><span class="answer">input</span><span class="answer">input</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="56e1cbe2cd28a01900c67bb0"><p> <strong class="question">According to polynomial time reduction squaring can ultimately be logically reduced to what?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">multiplication</span><span class="answer">multiplication</span><span class="answer">multiplication</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad5648b5b96ef001a10ad94"><p> <strong class="question">What is the least used type of reduction?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad5648b5b96ef001a10ad95"><p> <strong class="question">What is the meaning of polynomial-space reduction?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad5648b5b96ef001a10ad96"><p> <strong class="question">What can the problem of dividing an integer be reduced to?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad5648b5b96ef001a10ad97"><p> <strong class="question">What does one not need to remain constant in a multiplication algorithm to produce the same outcome whether multiplying or squaring two integers?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad5648b5b96ef001a10ad98"><p> <strong class="question">What is more difficult that multiplication?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div></div></div></div></div><div class="para-wrap"><div class="row"><div class="col-md-6"><pre>This motivates the concept of a problem being hard for a complexity class. A problem X is hard for a class of problems C if every problem in C can be reduced to X. Thus no problem in C is harder than X, since an algorithm for X allows us to solve any problem in C. Of course, the notion of hard problems depends on the type of reduction being used. For complexity classes larger than P, polynomial-time reductions are commonly used. In particular, the set of problems that are hard for NP is the set of NP-hard problems.</pre></div><div class="col-md-6"><div class="qas-wrap"><div class="qa-wrap" data-id="56e1ce08e3433e14004231a4"><p> <strong class="question">The complexity of problems often depends on what?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">the type of reduction being used</span><span class="answer">the type of reduction being used</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="56e1ce08e3433e14004231a5"><p> <strong class="question">What would create a conflict between a problem X and problem C within the context of reduction? </strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">if every problem in C can be reduced to X</span><span class="answer">problem in C is harder than X</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="56e1ce08e3433e14004231a6"><p> <strong class="question">An algorithm for X which reduces to C would us to do what?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">solve any problem in C</span><span class="answer">solve any problem in C</span><span class="answer">solve any problem in C</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="56e1ce08e3433e14004231a8"><p> <strong class="question">A problem set that that is hard for the expression NP can also be stated how?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">NP-hard</span><span class="answer">NP-hard</span><span class="answer">NP-hard problems</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad565575b96ef001a10adb2"><p> <strong class="question">What does the complexity of problems not often depend on?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad565575b96ef001a10adb3"><p> <strong class="question">What would not create a conflict between a problem X and problem C within the context of reduction?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad565575b96ef001a10adb4"><p> <strong class="question">What problem in C is harder than X?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad565575b96ef001a10adb5"><p> <strong class="question">How is a problem set that is hard for expression QP be stated?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div></div></div></div></div><div class="para-wrap"><div class="row"><div class="col-md-6"><pre>If a problem X is in C and hard for C, then X is said to be complete for C. This means that X is the hardest problem in C. (Since many problems could be equally hard, one might say that X is one of the hardest problems in C.) Thus the class of NP-complete problems contains the most difficult problems in NP, in the sense that they are the ones most likely not to be in P. Because the problem P = NP is not solved, being able to reduce a known NP-complete problem, Π2, to another problem, Π1, would indicate that there is no known polynomial-time solution for Π1. This is because a polynomial-time solution to Π1 would yield a polynomial-time solution to Π2. Similarly, because all NP problems can be reduced to the set, finding an NP-complete problem that can be solved in polynomial time would mean that P = NP.</pre></div><div class="col-md-6"><div class="qas-wrap"><div class="qa-wrap" data-id="56e1d9fee3433e14004231cb"><p> <strong class="question">The hardest problems in NP can be analogously written as what class of problems?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">NP-complete</span><span class="answer">NP-complete</span><span class="answer">NP-complete</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="56e1d9fee3433e14004231cc"><p> <strong class="question">NP complete problems contain the lowest likelihood of being located in what problem class?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">NP</span><span class="answer">P</span><span class="answer">P</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="56e1d9fee3433e14004231cd"><p> <strong class="question">If P = NP is unsolved, and reduction is applied to a known NP-complete problem vis a vis Π2 to  Π1, what conclusion can be drawn for Π1?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">there is no known polynomial-time solution</span><span class="answer">no known polynomial-time solution</span><span class="answer">there is no known polynomial-time solution</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="56e1d9fee3433e14004231ce"><p> <strong class="question">If polynomial time can be utilized within an NP-complete problem, what does the imply P is equal to?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">NP</span><span class="answer">NP</span><span class="answer">NP</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad566375b96ef001a10adce"><p> <strong class="question">What happens if a problem X is in C, and soft for C?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad566375b96ef001a10adcf"><p> <strong class="question">What is the softest problem in C?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad566375b96ef001a10add0"><p> <strong class="question">What is class contains the the least difficult problems in NP?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad566375b96ef001a10add1"><p> <strong class="question">What would indicate that there is a known polynomial-time solution for Ii1?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div></div></div></div></div><div class="para-wrap"><div class="row"><div class="col-md-6"><pre>The complexity class P is often seen as a mathematical abstraction modeling those computational tasks that admit an efficient algorithm. This hypothesis is called the Cobham–Edmonds thesis. The complexity class NP, on the other hand, contains many problems that people would like to solve efficiently, but for which no efficient algorithm is known, such as the Boolean satisfiability problem, the Hamiltonian path problem and the vertex cover problem. Since deterministic Turing machines are special non-deterministic Turing machines, it is easily observed that each problem in P is also member of the class NP.</pre></div><div class="col-md-6"><div class="qas-wrap"><div class="qa-wrap" data-id="56e1dc62cd28a01900c67bca"><p> <strong class="question">What complexity class is characterized by a computational tasks and efficient algorithms?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">P</span><span class="answer">P</span><span class="answer">P</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="56e1dc62cd28a01900c67bcb"><p> <strong class="question">What hypothesis is associated with the complexity class of P viewed as a mathematical abstraction with efficient algorithmic functionality?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">Cobham–Edmonds thesis</span><span class="answer">Cobham–Edmonds thesis</span><span class="answer">Cobham–Edmonds thesis</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="56e1dc62cd28a01900c67bcc"><p> <strong class="question">What complexity class is commonly characterized by unknown algorithms to enhance solvability?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">NP</span><span class="answer">NP</span><span class="answer">NP</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="56e1dc62cd28a01900c67bcd"><p> <strong class="question">What is an example of a problem that rests within the NP complexity class?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">Boolean satisfiability problem</span><span class="answer">Boolean satisfiability problem</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="56e1dc62cd28a01900c67bce"><p> <strong class="question">In what theoretical machine is it confirmed that a problem in P belies membership in the NP class?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">Turing machines</span><span class="answer">deterministic Turing machines</span><span class="answer">deterministic Turing machines</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad567055b96ef001a10adea"><p> <strong class="question">What is often seen as a scientific abstraction modeling those computational tasks that admit an efficient algorithm?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad567055b96ef001a10adeb"><p> <strong class="question">What theory is the Cobham-Edward thesis?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad567055b96ef001a10adec"><p> <strong class="question">What complexity class is not commonly characterized by unknown algorithms to enhance solubility?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad567055b96ef001a10aded"><p> <strong class="question">What is an example of a problem that rests within the NP simplicity class?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad567055b96ef001a10adee"><p> <strong class="question">What ,theoretical machine did not confirm that a problem in P belies membership in the NX class?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div></div></div></div></div><div class="para-wrap"><div class="row"><div class="col-md-6"><pre>The question of whether P equals NP is one of the most important open questions in theoretical computer science because of the wide implications of a solution. If the answer is yes, many important problems can be shown to have more efficient solutions. These include various types of integer programming problems in operations research, many problems in logistics, protein structure prediction in biology, and the ability to find formal proofs of pure mathematics theorems. The P versus NP problem is one of the Millennium Prize Problems proposed by the Clay Mathematics Institute. There is a US$1,000,000 prize for resolving the problem.</pre></div><div class="col-md-6"><div class="qas-wrap"><div class="qa-wrap" data-id="56e1ddfce3433e14004231d5"><p> <strong class="question">If P is ultimately proven to be equal tot NP, what effect would this have on the efficiency of problems?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">more efficient solutions</span><span class="answer">shown to have more efficient solutions</span><span class="answer">many important problems can be shown to have more efficient solutions</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="56e1ddfce3433e14004231d6"><p> <strong class="question">What is a particular problem in biology that would benefit from determining that P = NP?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">protein structure prediction</span><span class="answer">protein structure prediction</span><span class="answer">protein structure prediction</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="56e1ddfce3433e14004231d8"><p> <strong class="question">What is the prize offered for finding a solution to P=NP?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">$1,000,000</span><span class="answer">US$1,000,000</span><span class="answer">US$1,000,000</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad568175b96ef001a10ae10"><p> <strong class="question">What is one of the least important open questions in theoretical computer science?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad568175b96ef001a10ae11"><p> <strong class="question">What effect would happen if P is ultimately proven to not equal NP ?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad568175b96ef001a10ae12"><p> <strong class="question">What is a particular problem in chemistry that would benefit from determining that P = NP?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad568175b96ef001a10ae13"><p> <strong class="question">What problem was proposed by Clay Mathematics Institute at the Alpha Prize Problems?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad568175b96ef001a10ae14"><p> <strong class="question">What was the prize for finding a solution to P=NP at the the Alpha Prize Problems?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div></div></div></div></div><div class="para-wrap"><div class="row"><div class="col-md-6"><pre>It was shown by Ladner that if P ≠ NP then there exist problems in NP that are neither in P nor NP-complete. Such problems are called NP-intermediate problems. The graph isomorphism problem, the discrete logarithm problem and the integer factorization problem are examples of problems believed to be NP-intermediate. They are some of the very few NP problems not known to be in P or to be NP-complete.</pre></div><div class="col-md-6"><div class="qas-wrap"><div class="qa-wrap" data-id="56e1ded7cd28a01900c67bd4"><p> <strong class="question">Who demonstrated that P= NP implies problems not present in P or NP-complete?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">Ladner</span><span class="answer">Ladner</span><span class="answer">Ladner</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="56e1ded7cd28a01900c67bd5"><p> <strong class="question">What is the name for a problem that meets Ladner's assertion?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">NP-intermediate problems</span><span class="answer">NP-intermediate problems</span><span class="answer">NP-intermediate</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="56e1ded7cd28a01900c67bd6"><p> <strong class="question">What is an example of an NP-intermediate problem not known to exist in P or NP-complete? </strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">graph isomorphism problem</span><span class="answer">the discrete logarithm problem</span><span class="answer">graph isomorphism problem, the discrete logarithm problem and the integer factorization problem</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad568d35b96ef001a10ae1a"><p> <strong class="question">Who showed that if P=NQ then there exists problems in NQ that are neither P nor NQ-complete?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad568d35b96ef001a10ae1b"><p> <strong class="question">What is the name a a problem that meets Ladder's assertion?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad568d35b96ef001a10ae1c"><p> <strong class="question">What is not example of an NP-intermediate problem not known to exist in P or NP-complete?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad568d35b96ef001a10ae1d"><p> <strong class="question">What are four examples of problems believed to be NP=intermediate?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div></div></div></div></div><div class="para-wrap"><div class="row"><div class="col-md-6"><pre>The graph isomorphism problem is the computational problem of determining whether two finite graphs are isomorphic. An important unsolved problem in complexity theory is whether the graph isomorphism problem is in P, NP-complete, or NP-intermediate. The answer is not known, but it is believed that the problem is at least not NP-complete. If graph isomorphism is NP-complete, the polynomial time hierarchy collapses to its second level. Since it is widely believed that the polynomial hierarchy does not collapse to any finite level, it is believed that graph isomorphism is not NP-complete. The best algorithm for this problem, due to Laszlo Babai and Eugene Luks has run time 2O(√(n log(n))) for graphs with n vertices.</pre></div><div class="col-md-6"><div class="qas-wrap"><div class="qa-wrap" data-id="56e1e9dfe3433e14004231fc"><p> <strong class="question">What is the problem attributed to defining if two finite graphs are isomorphic?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">The graph isomorphism problem</span><span class="answer">graph isomorphism</span><span class="answer">The graph isomorphism problem</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="56e1e9dfe3433e14004231fd"><p> <strong class="question">What class is most commonly not ascribed to the graph isomorphism problem in spite of definitive determination?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">NP-complete</span><span class="answer">NP-complete</span><span class="answer">NP-complete</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="56e1e9dfe3433e14004231fe"><p> <strong class="question">What finite hierarchy implies that the graph isomorphism problem is NP-complete? </strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">polynomial time hierarchy</span><span class="answer">polynomial time</span><span class="answer">polynomial time hierarchy</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="56e1e9dfe3433e14004231ff"><p> <strong class="question">To what level would the polynomial time hierarchy collapse if graph isomorphism is NP-complete?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">second level</span><span class="answer">second</span><span class="answer">second</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="56e1e9dfe3433e1400423200"><p> <strong class="question">Who are commonly associated with the algorithm typically considered the most effective with respect to finite polynomial hierarchy and graph isomorphism?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">Laszlo Babai and Eugene Luks</span><span class="answer">Babai and Eugene Luks</span><span class="answer">Laszlo Babai and Eugene Luks</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad569c05b96ef001a10ae36"><p> <strong class="question">What is the graph isolation problem? </strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad569c05b96ef001a10ae37"><p> <strong class="question">What is the problem attributed to defining if three finite graphs are isomorphic?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad569c05b96ef001a10ae38"><p> <strong class="question">What is an important solved problem in complexity theory?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad569c05b96ef001a10ae39"><p> <strong class="question">What infinite hierarchy implies that the graph isomorphism problem s NQ-complete?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad569c05b96ef001a10ae3a"><p> <strong class="question">What would the polynomial hierarchy collapse if graph isomorphism is NQ-complete?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div></div></div></div></div><div class="para-wrap"><div class="row"><div class="col-md-6"><pre>The integer factorization problem is the computational problem of determining the prime factorization of a given integer. Phrased as a decision problem, it is the problem of deciding whether the input has a factor less than k. No efficient integer factorization algorithm is known, and this fact forms the basis of several modern cryptographic systems, such as the RSA algorithm. The integer factorization problem is in NP and in co-NP (and even in UP and co-UP). If the problem is NP-complete, the polynomial time hierarchy will collapse to its first level (i.e., NP will equal co-NP). The best known algorithm for integer factorization is the general number field sieve, which takes time O(e(64/9)1/3(n.log 2)1/3(log (n.log 2))2/3) to factor an n-bit integer. However, the best known quantum algorithm for this problem, Shor's algorithm, does run in polynomial time. Unfortunately, this fact doesn't say much about where the problem lies with respect to non-quantum complexity classes.</pre></div><div class="col-md-6"><div class="qas-wrap"><div class="qa-wrap" data-id="56e1ec83cd28a01900c67c0a"><p> <strong class="question">What computational problem is commonly associated with prime factorization?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">The integer factorization problem</span><span class="answer">integer factorization</span><span class="answer">integer factorization problem</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="56e1ec83cd28a01900c67c0b"><p> <strong class="question">The integer factorization problem essentially seeks to determine if the value of of an input is less than what variable? </strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">k</span><span class="answer">k</span><span class="answer">k</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="56e1ec83cd28a01900c67c0c"><p> <strong class="question">That there currently exists no known integer factorization problem underpins what commonly used system?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">modern cryptographic systems</span><span class="answer">modern cryptographic systems</span><span class="answer">RSA algorithm</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="56e1ec83cd28a01900c67c0e"><p> <strong class="question">What is the most well-known algorithm associated with the integer factorization problem?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">the general number field sieve</span><span class="answer">RSA</span><span class="answer">general number field sieve</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad56aea5b96ef001a10ae48"><p> <strong class="question">What is the integer practice problem?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad56aea5b96ef001a10ae49"><p> <strong class="question">What computational problem is not commonly associated with prime factorization?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad56aea5b96ef001a10ae4a"><p> <strong class="question">What problem is phrased on deciding whether the input has a factor more than k?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad56aea5b96ef001a10ae4b"><p> <strong class="question">What problem would have polynomial time hierarchy that would collapse to its second level?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad56aea5b96ef001a10ae4c"><p> <strong class="question">What is the least well known algorithm associated with the the integer factorization problem?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div></div></div></div></div><div class="para-wrap"><div class="row"><div class="col-md-6"><pre>Many known complexity classes are suspected to be unequal, but this has not been proved. For instance P ⊆ NP ⊆ PP ⊆ PSPACE, but it is possible that P = PSPACE. If P is not equal to NP, then P is not equal to PSPACE either. Since there are many known complexity classes between P and PSPACE, such as RP, BPP, PP, BQP, MA, PH, etc., it is possible that all these complexity classes collapse to one class. Proving that any of these classes are unequal would be a major breakthrough in complexity theory.</pre></div><div class="col-md-6"><div class="qas-wrap"><div class="qa-wrap" data-id="56e1ee4de3433e1400423210"><p> <strong class="question">What is the unproven assumption generally ascribed to the value of complexity classes?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">suspected to be unequal</span><span class="answer">unequal</span><span class="answer">Many known complexity classes are suspected to be unequal</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="56e1ee4de3433e1400423211"><p> <strong class="question">What is an expression that can be used to illustrate the suspected inequality of complexity classes?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">P ⊆ NP ⊆ PP ⊆ PSPACE</span><span class="answer">P ⊆ NP ⊆ PP ⊆ PSPACE</span><span class="answer">P ⊆ NP ⊆ PP ⊆ PSPACE</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="56e1ee4de3433e1400423212"><p> <strong class="question">Where can the complexity classes RP, BPP, PP, BQP, MA, and PH be located?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">between P and PSPACE</span><span class="answer">between P and PSPACE</span><span class="answer">between P and PSPACE</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="56e1ee4de3433e1400423214"><p> <strong class="question">What evidence between and among complexity classes would signify a theoretical watershed for complexity theory?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">Proving that any of these classes are unequal</span><span class="answer">Proving that any of these classes are unequal</span><span class="answer">Proving that any of these classes are unequal</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad56bcd5b96ef001a10ae62"><p> <strong class="question">What is the proven assumption generally ascribed to the value of complexity classes?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad56bcd5b96ef001a10ae63"><p> <strong class="question">What is an expression that caan be used to illustrate the suspected in equality of complexity classes?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad56bcd5b96ef001a10ae64"><p> <strong class="question">Where can complexity classes RPP, BPP, PPP, BQP, MA, and PH be located?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad56bcd5b96ef001a10ae65"><p> <strong class="question">What is impossible for the complexity classes RP, BPP, PP, BQP, MA, and PH?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad56bcd5b96ef001a10ae66"><p> <strong class="question">What would not be a major breakthrough in complexity theory?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div></div></div></div></div><div class="para-wrap"><div class="row"><div class="col-md-6"><pre>Along the same lines, co-NP is the class containing the complement problems (i.e. problems with the yes/no answers reversed) of NP problems. It is believed that NP is not equal to co-NP; however, it has not yet been proven. It has been shown that if these two complexity classes are not equal then P is not equal to NP.</pre></div><div class="col-md-6"><div class="qas-wrap"><div class="qa-wrap" data-id="56e1efa0e3433e140042321a"><p> <strong class="question">In what complexity class do complement problems of NP problems exist?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">co-NP</span><span class="answer">co-NP</span><span class="answer">co-NP</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="56e1efa0e3433e140042321b"><p> <strong class="question">How do the yes/no answers of a complement problem of NP appear?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">reversed</span><span class="answer">reversed</span><span class="answer">reversed</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="56e1efa0e3433e140042321c"><p> <strong class="question">What is commonly believed to be the value relationship between P and co-NP</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">not equal</span><span class="answer">not equal</span><span class="answer">not equal</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="56e1efa0e3433e140042321d"><p> <strong class="question">What implication can be derived for P and NP if P and co-NP are established to be unequal?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">P is not equal to NP</span><span class="answer">not equal</span><span class="answer">P is not equal to NP</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad56c6b5b96ef001a10ae6c"><p> <strong class="question">What complexity class do incompatible problems of NP problems exist?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad56c6b5b96ef001a10ae6d"><p> <strong class="question">How do the yes/no answers of an incompatible problem of of APPEAR?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad56c6b5b96ef001a10ae6e"><p> <strong class="question">What is not commonly believed to be the value relationship between P and co-NP?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad56c6b5b96ef001a10ae6f"><p> <strong class="question">What implication can not be derived for P and NP is P and co-NP are established to be unequal?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div></div></div></div></div><div class="para-wrap"><div class="row"><div class="col-md-6"><pre>Similarly, it is not known if L (the set of all problems that can be solved in logarithmic space) is strictly contained in P or equal to P. Again, there are many complexity classes between the two, such as NL and NC, and it is not known if they are distinct or equal classes.</pre></div><div class="col-md-6"><div class="qas-wrap"><div class="qa-wrap" data-id="56e1f10ee3433e1400423222"><p> <strong class="question">What variable is associated with all problems solved within logarithmic space?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">L</span><span class="answer">L</span><span class="answer">L</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="56e1f10ee3433e1400423223"><p> <strong class="question">Though unkown, what are the most commonly ascribed attributes of L in relation to P</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">strictly contained in P or equal to P</span><span class="answer">contained in P or equal to P.</span><span class="answer">strictly contained in P or equal to P</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="56e1f10ee3433e1400423224"><p> <strong class="question">What lies between L and P that prevents a definitive determination of the relationship between L and P?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">complexity classes</span><span class="answer">many complexity classes</span><span class="answer">many complexity classes</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="56e1f10ee3433e1400423225"><p> <strong class="question">What are two complexity classes between L and P?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">NL and NC</span><span class="answer">NL and NC</span><span class="answer">NL and NC</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="56e1f10ee3433e1400423226"><p> <strong class="question">What is unknown about the complexity classes between L and P that further prevents determining the value relationship between L and P?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">if they are distinct or equal classes</span><span class="answer">if they are distinct or equal classes</span><span class="answer">if they are distinct or equal classes</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad56d3e5b96ef001a10ae84"><p> <strong class="question">What variable is not associated with all problems solved within logarithmic space?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad56d3e5b96ef001a10ae85"><p> <strong class="question">What are the least commonly ascribed attributes of L in relation to P?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad56d3e5b96ef001a10ae86"><p> <strong class="question">What does not lie between L and P that allows a definitive determination of the relationship between L and P?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad56d3e5b96ef001a10ae87"><p> <strong class="question">What are three complexity classes between L and P?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad56d3e5b96ef001a10ae88"><p> <strong class="question">What is known about the complexity between L and P that prevents determining the value between L and P?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div></div></div></div></div><div class="para-wrap"><div class="row"><div class="col-md-6"><pre>Problems that can be solved in theory (e.g., given large but finite time), but which in practice take too long for their solutions to be useful, are known as intractable problems. In complexity theory, problems that lack polynomial-time solutions are considered to be intractable for more than the smallest inputs. In fact, the Cobham–Edmonds thesis states that only those problems that can be solved in polynomial time can be feasibly computed on some computational device. Problems that are known to be intractable in this sense include those that are EXPTIME-hard. If NP is not the same as P, then the NP-complete problems are also intractable in this sense. To see why exponential-time algorithms might be unusable in practice, consider a program that makes 2n operations before halting. For small n, say 100, and assuming for the sake of example that the computer does 1012 operations each second, the program would run for about 4 × 1010 years, which is the same order of magnitude as the age of the universe. Even with a much faster computer, the program would only be useful for very small instances and in that sense the intractability of a problem is somewhat independent of technological progress. Nevertheless, a polynomial time algorithm is not always practical. If its running time is, say, n15, it is unreasonable to consider it efficient and it is still useless except on small instances.</pre></div><div class="col-md-6"><div class="qas-wrap"><div class="qa-wrap" data-id="56e1fc57e3433e140042322c"><p> <strong class="question">Problems capable of theoretical solutions but consuming unreasonable time in practical application are known as what?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">intractable problems</span><span class="answer">intractable problems</span><span class="answer">intractable</span><span class="answer">intractable</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="56e1fc57e3433e140042322f"><p> <strong class="question">Intractable problems lacking polynomial time solutions necessarily negate the practical efficacy of what type of algorithm?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">exponential-time algorithms</span><span class="answer">exponential-time</span><span class="answer">exponential-time algorithms</span><span class="answer">exponential-time algorithms</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="56e1fc57e3433e1400423230"><p> <strong class="question">If NP is not equal to P, viewed through this lens, what type of problems can also be considered intractable?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">NP-complete problems</span><span class="answer">NP-complete</span><span class="answer">NP-complete</span><span class="answer">NP-complete</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad56e5c5b96ef001a10ae9e"><p> <strong class="question">What are problems that cannot be solved in theory, but which in practice take too long for their solutions to be useful?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad56e5c5b96ef001a10ae9f"><p> <strong class="question">When are problems that have polynomial-tome solutions in complexity theory?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad56e5c5b96ef001a10aea0"><p> <strong class="question">What states that only problems that cannot be solved in polynomial time can be feasibly computed on some computational device?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad56e5c5b96ef001a10aea1"><p> <strong class="question">When would a program not be useful for very small instances and in that sense the intractability of a problem is somewhat independent of technological progress?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad56e5c5b96ef001a10aea2"><p> <strong class="question">What algorithm is always practical?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div></div></div></div></div><div class="para-wrap"><div class="row"><div class="col-md-6"><pre>What intractability means in practice is open to debate. Saying that a problem is not in P does not imply that all large cases of the problem are hard or even that most of them are. For example, the decision problem in Presburger arithmetic has been shown not to be in P, yet algorithms have been written that solve the problem in reasonable times in most cases. Similarly, algorithms can solve the NP-complete knapsack problem over a wide range of sizes in less than quadratic time and SAT solvers routinely handle large instances of the NP-complete Boolean satisfiability problem.</pre></div><div class="col-md-6"><div class="qas-wrap"><div class="qa-wrap" data-id="56e1febfe3433e1400423236"><p> <strong class="question">What eponymous variation of arithmetic presents a decision problem not evidenced in P?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">Presburger arithmetic</span><span class="answer">Presburger</span><span class="answer">Presburger arithmetic</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="56e1febfe3433e1400423237"><p> <strong class="question">Despite the Presburger problem, and in view of intractability, what has been done to establish solutions in reasonable periods of time?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">algorithms have been written</span><span class="answer">algorithms have been written</span><span class="answer">algorithms have been written that solve the problem in reasonable times in most cases</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="56e1febfe3433e1400423238"><p> <strong class="question">What is an example of a problem to which effective algorithms have provided a solution in spite of the intractability associated with the breadth of sizes?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">NP-complete knapsack problem</span><span class="answer">NP-complete knapsack</span><span class="answer">the NP-complete knapsack problem</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="56e1febfe3433e1400423239"><p> <strong class="question">How quickly can an algorithm solve an NP-complete knapsack problem?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">in less than quadratic time</span><span class="answer">less than quadratic time</span><span class="answer">less than quadratic time</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="56e1febfe3433e140042323a"><p> <strong class="question">What is the example of another problem characterized by large instances that is routinely solved by SAT handlers employing efficient algorithms?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">NP-complete Boolean satisfiability problem</span><span class="answer">NP-complete Boolean satisfiability</span><span class="answer">the NP-complete Boolean satisfiability problem</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad56ef05b96ef001a10aea8"><p> <strong class="question">What unknown variation of arithmetic presents a decision problem not evidenced in P?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad56ef05b96ef001a10aea9"><p> <strong class="question">What has not been done to establish solutions in reasonable period of time?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad56ef05b96ef001a10aeaa"><p> <strong class="question">What can not solve the NP-complete knapsack problem over a wide range of sizes in less than quadratic time?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad56ef05b96ef001a10aeab"><p> <strong class="question">What do SAT solvers not usually handle when testing?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div></div></div></div></div><div class="para-wrap"><div class="row"><div class="col-md-6"><pre>Before the actual research explicitly devoted to the complexity of algorithmic problems started off, numerous foundations were laid out by various researchers. Most influential among these was the definition of Turing machines by Alan Turing in 1936, which turned out to be a very robust and flexible simplification of a computer.</pre></div><div class="col-md-6"><div class="qas-wrap"><div class="qa-wrap" data-id="56e200e4cd28a01900c67c14"><p> <strong class="question">What tactic did researchers employ to offset the former deficit of work surrounding the complexity of algorithmic problems?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">foundations were laid out</span><span class="answer">numerous foundations were laid out</span><span class="answer">numerous foundations were laid out by various researchers</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="56e200e4cd28a01900c67c15"><p> <strong class="question">Who was the most influential researcher among those grappling with the deficit of work surrounding the complexity posed by algorithmic problems?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">Alan Turing</span><span class="answer">Alan Turing</span><span class="answer">Alan Turing</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="56e200e4cd28a01900c67c16"><p> <strong class="question">What theoretical device is attributed to Alan Turing?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">Turing machines</span><span class="answer">Turing machines</span><span class="answer">Turing machines</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="56e200e4cd28a01900c67c17"><p> <strong class="question">In what year was the Alan Turing's definitional model of a computing device received?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">1936</span><span class="answer">1936</span><span class="answer">1936</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="56e200e4cd28a01900c67c18"><p> <strong class="question">In the most basic sense what did a Turing machine emulate?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">a computer</span><span class="answer">a computer</span><span class="answer">a computer</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad56fe65b96ef001a10aec2"><p> <strong class="question">What were laid out by various companies?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad56fe65b96ef001a10aec3"><p> <strong class="question">What tactic did companies employ to offset the former deficit of work surrounding the complexity of algorithmic problems?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad56fe65b96ef001a10aec4"><p> <strong class="question">Who was the least influential researcher working on the complexity posed by algorithmic problems?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad56fe65b96ef001a10aec5"><p> <strong class="question">What device did Alan Turning invent in 1974?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad56fe65b96ef001a10aec6"><p> <strong class="question">What was the Turning calculator a robust and flexible simplification of?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div></div></div></div></div><div class="para-wrap"><div class="row"><div class="col-md-6"><pre>As Fortnow &amp; Homer (2003) point out, the beginning of systematic studies in computational complexity is attributed to the seminal paper &quot;On the Computational Complexity of Algorithms&quot; by Juris Hartmanis and Richard Stearns (1965), which laid out the definitions of time and space complexity and proved the hierarchy theorems. Also, in 1965 Edmonds defined a &quot;good&quot; algorithm as one with running time bounded by a polynomial of the input size.</pre></div><div class="col-md-6"><div class="qas-wrap"><div class="qa-wrap" data-id="56e202e9e3433e1400423240"><p> <strong class="question">What paper is commonly considered the bellwether ushering in systematic studies computational complexity?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">On the Computational Complexity of Algorithms</span><span class="answer">On the Computational Complexity of Algorithms</span><span class="answer">&quot;On the Computational Complexity of Algorithms&quot;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="56e202e9e3433e1400423241"><p> <strong class="question">What individuals were responsible for authoring &quot;On the Computational Complexity of Algorithms&quot;?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">Juris Hartmanis and Richard Stearns</span><span class="answer">Juris Hartmanis and Richard Stearns</span><span class="answer">Juris Hartmanis and Richard Stearns</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="56e202e9e3433e1400423242"><p> <strong class="question">In what year was Hatmanis and Stearn's seminal work in computational complexity received? </strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">1965</span><span class="answer">1965</span><span class="answer">1965</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="56e202e9e3433e1400423243"><p> <strong class="question">What complex measurements were defined by &quot;On the Computational Complexity of Algorithms&quot;?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">time and space</span><span class="answer">definitions of time and space complexity</span><span class="answer">time and space complexity</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="56e202e9e3433e1400423244"><p> <strong class="question">In what year did Edmond's characterize a &quot;good&quot; algorithm?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">1965</span><span class="answer">1965</span><span class="answer">1965</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad570b25b96ef001a10aedc"><p> <strong class="question">What seminal paper is commonly considered the beginning of sociology studies?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad570b25b96ef001a10aedd"><p> <strong class="question">Who wrote &quot;On the Computational Complexity of Science&quot;?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad570b25b96ef001a10aede"><p> <strong class="question">What seminal paper was written by Juris Hartmanis and Richard Stearns in 1975?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad570b25b96ef001a10aedf"><p> <strong class="question">What simple measurements were defined by &quot;On the Computational Complexity of Algorithms&quot;?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div></div></div></div></div><div class="para-wrap"><div class="row"><div class="col-md-6"><pre>Earlier papers studying problems solvable by Turing machines with specific bounded resources include  John Myhill's definition of linear bounded automata (Myhill 1960), Raymond Smullyan's study of rudimentary sets (1961), as well as Hisao Yamada's paper on real-time computations (1962). Somewhat earlier, Boris Trakhtenbrot (1956), a pioneer in the field from the USSR, studied another specific complexity measure. As he remembers:</pre></div><div class="col-md-6"><div class="qas-wrap"><div class="qa-wrap" data-id="56e2042ecd28a01900c67c1e"><p> <strong class="question">Who provided a definition of linear bounded automata in 1960?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">John Myhill</span><span class="answer">John Myhill</span><span class="answer">John Myhill</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="56e2042ecd28a01900c67c1f"><p> <strong class="question">In what year did Raymond Sullivan publish a study of rudimentary sets?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">1961</span><span class="answer">1961</span><span class="answer">1961</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="56e2042ecd28a01900c67c20"><p> <strong class="question">In 1962, who was responsible for the authorship of a paper published on real time-computations?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">Hisao Yamada</span><span class="answer">Hisao Yamada</span><span class="answer">Hisao Yamada</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad5719f5b96ef001a10aeec"><p> <strong class="question">Who wrote later papers studying problems solvable by Turning machines?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad5719f5b96ef001a10aeed"><p> <strong class="question">Who provided a definition of linear bounded automata in 1970?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad5719f5b96ef001a10aeee"><p> <strong class="question">What year did Dick Sullivan publish a study on rudimentary sets?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad5719f5b96ef001a10aeef"><p> <strong class="question">Who wrote a paper on real time computations in 1973?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad5719f5b96ef001a10aef0"><p> <strong class="question">Who was pioneer and studied specific complexity measure in 1948?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div></div></div></div></div><div class="para-wrap"><div class="row"><div class="col-md-6"><pre>Even though some proofs of complexity-theoretic theorems regularly assume some concrete choice of input encoding, one tries to keep the discussion abstract enough to be independent of the choice of encoding. This can be achieved by ensuring that different representations can be transformed into each other efficiently.</pre></div><div class="col-md-6"><div class="qas-wrap"><div class="qa-wrap" data-id="56e20a27cd28a01900c67c24"><p> <strong class="question">What is the concrete choice typically assumed by most complexity-theoretic theorems?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">input encoding</span><span class="answer">input encoding</span><span class="answer">input encoding</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="56e20a27cd28a01900c67c25"><p> <strong class="question">In the effort of maintaining a level of abstraction, what choice is typically left independent?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">encoding</span><span class="answer">encoding</span><span class="answer">encoding</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad53ac65b96ef001a10abac"><p> <strong class="question">What can not be achieved by ensuring different representations can transformed into each other efficiently?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad53ac65b96ef001a10abad"><p> <strong class="question">What is the abstract choice typically assumed by most complexity-theoretic theorems?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad53ac65b96ef001a10abae"><p> <strong class="question">What does not regularly use input coding as its concrete choice?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad53ac65b96ef001a10abaf"><p> <strong class="question">What choice is typically left dependent in an effort to maintain a level of abstraction?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div></div></div></div></div><div class="para-wrap"><div class="row"><div class="col-md-6"><pre>In 1967, Manuel Blum developed an axiomatic complexity theory based on his axioms and proved an important result, the so-called, speed-up theorem. The field really began to flourish in 1971 when the US researcher Stephen Cook and, working independently, Leonid Levin in the USSR, proved that there exist practically relevant problems that are NP-complete. In 1972, Richard Karp took this idea a leap forward with his landmark paper, &quot;Reducibility Among Combinatorial Problems&quot;, in which he showed that 21 diverse combinatorial and graph theoretical problems, each infamous for its computational intractability, are NP-complete.</pre></div><div class="col-md-6"><div class="qas-wrap"><div class="qa-wrap" data-id="56e20a3ae3433e140042324a"><p> <strong class="question">Who is responsible for axiomatic complexity theory?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">Manuel Blum</span><span class="answer">Manuel Blum</span><span class="answer">Manuel Blum</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="56e20a3ae3433e140042324b"><p> <strong class="question">What theorem was implicated by Manuel Blum's axioms?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">speed-up theorem</span><span class="answer">speed-up theorem</span><span class="answer">speed-up theorem</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="56e20a3ae3433e140042324d"><p> <strong class="question">What is the paper written by Richard Karp in 1972 that ushered in a new era of understanding between intractability and NP-complete problems?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">&quot;Reducibility Among Combinatorial Problems&quot;</span><span class="answer">Reducibility Among Combinatorial Problems</span><span class="answer">&quot;Reducibility Among Combinatorial Problems&quot;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="56e20a3ae3433e140042324e"><p> <strong class="question">How many combinatory and graph theoretical problems, formerly believed to be plagued by intractability, did Karp's paper address?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="answer">21</span><span class="answer">21</span><span class="answer">21</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad572b15b96ef001a10af06"><p> <strong class="question">Who developed an axiomatic complexity theory based on his axioms in 1974?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad572b15b96ef001a10af07"><p> <strong class="question">Who is responsible for the so-called, speed-up theorem n 1974?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad572b15b96ef001a10af08"><p> <strong class="question">Who proved that these exist practical relevant problems that are NP-complete in 1961?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad572b15b96ef001a10af09"><p> <strong class="question">Who wrote the paper &quot;Reductibility Among Combinatorial Problems&quot; in 1974?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div><div class="qa-wrap" data-id="5ad572b15b96ef001a10af0a"><p> <strong class="question">What book featured 25 diverse comninatorial and graph theoretical problems each famous for its computational intractability?</strong></p><ul class="list-unstyled"><li><p><i>Ground Truth Answers: </i><span class="no-answer">&lt;No Answer&gt;</span></p></li><li class="prediction-holder"><p><i>Prediction: </i><span class="prediction"></span></p></li></ul></div></div></div></div></div></div></div></div></div></div></div></div><nav class="navbar navbar-default navbar-static-bottom footer"><div class="container clearfix"><div class="rightNav"><div><ul class="nav navbar-nav navbar-right"><li><a href="/SQuAD-explorer/">SQuAD</a></li><li><a href="http://nlp.stanford.edu">Stanford NLP Group</a></li></ul></div></div></div></nav><script src="/SQuAD-explorer/bower_components/jquery/dist/jquery.min.js"></script><script src="/SQuAD-explorer/bower_components/bootstrap/dist/js/bootstrap.min.js"></script><script src="/SQuAD-explorer/javascripts/hilitorModified.js"></script><script src="/SQuAD-explorer/javascripts/removeStopWords.js"></script><script src="/SQuAD-explorer/javascripts/highlighting.js"></script><script src="/SQuAD-explorer/javascripts/evaluate.js"></script><script src="/SQuAD-explorer/javascripts/model.js"></script></body></html>